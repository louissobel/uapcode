From 3f4fca0eed57326e2ba4ca3bc0a753823d4d64ac Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 01:02:40 -0400
Subject: [PATCH 01/17] going slow

---
 .../browser/extensions/api/web_request/web_request_api_constants.cc  |    2 ++
 .../browser/extensions/api/web_request/web_request_api_constants.h   |    2 ++
 net/http/http_status_code_list.h                                     |    1 +
 3 files changed, 5 insertions(+)

diff --git a/chrome/browser/extensions/api/web_request/web_request_api_constants.cc b/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
index aca996f..92f6402 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
@@ -50,6 +50,7 @@ const char kOnHeadersReceivedEvent[] = "webRequest.onHeadersReceived";
 const char kOnResponseStartedEvent[] = "webRequest.onResponseStarted";
 const char kOnSendHeadersEvent[] = "webRequest.onSendHeaders";
 const char kOnAuthRequiredEvent[] = "webRequest.onAuthRequired";
+const char kOnAttestationRequiredEvent[] = "webRequest.onAttestationRequired";
 
 const char kOnBeforeRedirect[] = "onBeforeRedirect";
 const char kOnBeforeRequest[] = "onBeforeRequest";
@@ -60,6 +61,7 @@ const char kOnHeadersReceived[] = "onHeadersReceived";
 const char kOnResponseStarted[] = "onResponseStarted";
 const char kOnSendHeaders[] = "onSendHeaders";
 const char kOnAuthRequired[] = "onAuthRequired";
+const char kOnAttestationRequired[] = "onAttestationRequired";
 
 const char kInvalidRedirectUrl[] = "redirectUrl '*' is not a valid URL.";
 const char kInvalidBlockingResponse[] =
diff --git a/chrome/browser/extensions/api/web_request/web_request_api_constants.h b/chrome/browser/extensions/api/web_request/web_request_api_constants.h
index 3dee75e..66f6577 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api_constants.h
+++ b/chrome/browser/extensions/api/web_request/web_request_api_constants.h
@@ -51,6 +51,7 @@ extern const char kUsernameKey[];
 extern const char kPasswordKey[];
 
 // Events.
+extern const char kOnAttestationRequiredEvent[];
 extern const char kOnAuthRequiredEvent[];
 extern const char kOnBeforeRedirectEvent[];
 extern const char kOnBeforeRequestEvent[];
@@ -62,6 +63,7 @@ extern const char kOnResponseStartedEvent[];
 extern const char kOnSendHeadersEvent[];
 
 // Stages.
+extern const char kOnAttestationRequired[];
 extern const char kOnAuthRequired[];
 extern const char kOnBeforeRedirect[];
 extern const char kOnBeforeRequest[];
diff --git a/net/http/http_status_code_list.h b/net/http/http_status_code_list.h
index 75c2304..d365364 100644
--- a/net/http/http_status_code_list.h
+++ b/net/http/http_status_code_list.h
@@ -57,6 +57,7 @@ HTTP_STATUS(UNSUPPORTED_MEDIA_TYPE, 415, "Unsupported Media Type")
 HTTP_STATUS(REQUESTED_RANGE_NOT_SATISFIABLE, 416,
             "Requested Range Not Satisfiable")
 HTTP_STATUS(EXPECTATION_FAILED, 417, "Expectation Failed")
+HTTP_STATUS(ATTESTATION_REQUIRED, 421, "Attestation Required")
 
 // Server error 5xx
 HTTP_STATUS(INTERNAL_SERVER_ERROR, 500, "Internal Server Error")
-- 
1.7.10.2 (Apple Git-33)


From e85abdd4145e98ebebc54240ad45c3bc1718848a Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 01:12:36 -0400
Subject: [PATCH 02/17] ok, add that

---
 chrome/browser/extensions/api/web_request/web_request_api.cc |    2 ++
 chrome/browser/extensions/api/web_request/web_request_api.h  |    7 ++++---
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/chrome/browser/extensions/api/web_request/web_request_api.cc b/chrome/browser/extensions/api/web_request/web_request_api.cc
index 1b4fe41..de59b7f 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api.cc
@@ -126,6 +126,8 @@ const char* GetRequestStageAsString(
       return keys::kOnBeforeRedirect;
     case ExtensionWebRequestEventRouter::kOnAuthRequired:
       return keys::kOnAuthRequired;
+    case ExtensionWebRequestEventRouter::kOnAttestationRequired:
+      return keys::kOnAttestationRequired;
     case ExtensionWebRequestEventRouter::kOnResponseStarted:
       return keys::kOnResponseStarted;
     case ExtensionWebRequestEventRouter::kOnErrorOccurred:
diff --git a/chrome/browser/extensions/api/web_request/web_request_api.h b/chrome/browser/extensions/api/web_request/web_request_api.h
index 8a2795b..26848d9 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.h
+++ b/chrome/browser/extensions/api/web_request/web_request_api.h
@@ -102,9 +102,10 @@ class ExtensionWebRequestEventRouter
     kOnHeadersReceived = 1 << 3,
     kOnBeforeRedirect = 1 << 4,
     kOnAuthRequired = 1 << 5,
-    kOnResponseStarted = 1 << 6,
-    kOnErrorOccurred = 1 << 7,
-    kOnCompleted = 1 << 8,
+    kOnAttestationRequired = 1 << 6,
+    kOnResponseStarted = 1 << 7,
+    kOnErrorOccurred = 1 << 8,
+    kOnCompleted = 1 << 9,
   };
 
   // Internal representation of the webRequest.RequestFilter type, used to
-- 
1.7.10.2 (Apple Git-33)


From f6c73490ab8a3b7212dbe5f5e1e41418466c25b5 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 01:42:09 -0400
Subject: [PATCH 03/17] ok

---
 .../extensions/api/web_request/web_request_api.cc       |   15 +++++++++++----
 net/base/auth.cc                                        |    3 ++-
 net/base/auth.h                                         |    3 +++
 3 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/chrome/browser/extensions/api/web_request/web_request_api.cc b/chrome/browser/extensions/api/web_request/web_request_api.cc
index de59b7f..f3cd016 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api.cc
@@ -907,10 +907,17 @@ ExtensionWebRequestEventRouter::OnAuthRequired(
     return net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_NO_ACTION;
 
   int extra_info_spec = 0;
-  std::vector<const EventListener*> listeners =
-      GetMatchingListeners(profile, extension_info_map,
-                           keys::kOnAuthRequiredEvent, request,
-                           &extra_info_spec);
+  std::vector<const EventListener*> listeners;
+  if (auth_info.is_attestation) {
+      listeners = GetMatchingListeners(profile, extension_info_map,
+                             keys::kOnAttestationRequiredEvent, request,
+                             &extra_info_spec);
+  } else {
+      listeners = GetMatchingListeners(profile, extension_info_map,
+                             keys::kOnAuthRequiredEvent, request,
+                             &extra_info_spec);
+  }
+
   if (listeners.empty())
     return net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_NO_ACTION;
 
diff --git a/net/base/auth.cc b/net/base/auth.cc
index 332e188..ade0851 100644
--- a/net/base/auth.cc
+++ b/net/base/auth.cc
@@ -14,7 +14,8 @@ bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {
   return (this->is_proxy == that.is_proxy &&
           this->challenger.Equals(that.challenger) &&
           this->scheme == that.scheme &&
-          this->realm == that.realm);
+          this->realm == that.realm &&
+          this->is_attestation == that.is_attestation);
 }
 
 AuthChallengeInfo::~AuthChallengeInfo() {
diff --git a/net/base/auth.h b/net/base/auth.h
index 62a59c8..9a162ba 100644
--- a/net/base/auth.h
+++ b/net/base/auth.h
@@ -30,6 +30,9 @@ class NET_EXPORT AuthChallengeInfo :
   // The service issuing the challenge.
   HostPortPair challenger;
 
+  // Is this an attestion request?
+  bool is_attestation;
+
   // The authentication scheme used, such as "basic" or "digest". If the
   // |source| is FTP_SERVER, this is an empty string. The encoding is ASCII.
   std::string scheme;
-- 
1.7.10.2 (Apple Git-33)


From 10b4c5df845369e5b1b94091e3ba390993c2296c Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 13:22:43 -0400
Subject: [PATCH 04/17] got my own auth handler to show up

---
 net/http/http_attestation_handler.cc  |   78 +++++++++++++++++++++++++++++++++
 net/http/http_attestation_handler.h   |   53 ++++++++++++++++++++++
 net/http/http_auth.cc                 |    1 +
 net/http/http_auth.h                  |    1 +
 net/http/http_auth_handler_factory.cc |    6 +++
 net/net.gypi                          |    2 +
 6 files changed, 141 insertions(+)
 create mode 100644 net/http/http_attestation_handler.cc
 create mode 100644 net/http/http_attestation_handler.h

diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
new file mode 100644
index 0000000..325bf6f
--- /dev/null
+++ b/net/http/http_attestation_handler.cc
@@ -0,0 +1,78 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/http/http_attestation_handler.h"
+
+#include <string>
+
+#include "base/base64.h"
+#include "base/i18n/icu_string_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_auth.h"
+#include "net/http/http_auth_challenge_tokenizer.h"
+
+namespace net {
+
+bool HttpAttestationHandler::Init(HttpAuthChallengeTokenizer* challenge) {
+  auth_scheme_ = HttpAuth::AUTH_SCHEME_ATTESTATION;
+  score_ = 1;
+  properties_ = 0;
+  return ParseChallenge(challenge);
+}
+
+bool HttpAttestationHandler::ParseChallenge(
+    HttpAuthChallengeTokenizer* challenge) {
+
+  // Verify the challenge's auth-scheme.
+  if (!LowerCaseEqualsASCII(challenge->scheme(), "attestation"))
+    return false;
+
+  realm_ = "attest/please";
+  return true;
+}
+
+HttpAuth::AuthorizationResult HttpAttestationHandler::HandleAnotherChallenge(
+    HttpAuthChallengeTokenizer* challenge) {
+  return HttpAuth::AUTHORIZATION_RESULT_REJECT;
+}
+
+int HttpAttestationHandler::GenerateAuthTokenImpl(
+    const AuthCredentials* credentials, const HttpRequestInfo*,
+    const CompletionCallback&, std::string* auth_token) {
+  DCHECK(credentials);
+  // TODO(eroman): is this the right encoding of username/password?
+  std::string base64_username_password;
+  base::Base64Encode(base::UTF16ToUTF8(credentials->username()) + ":" +
+                         base::UTF16ToUTF8(credentials->password()),
+                     &base64_username_password);
+  *auth_token = "Basic " + base64_username_password;
+  return OK;
+}
+
+HttpAttestationHandler::Factory::Factory() {
+}
+
+HttpAttestationHandler::Factory::~Factory() {
+}
+
+int HttpAttestationHandler::Factory::CreateAuthHandler(
+    HttpAuthChallengeTokenizer* challenge,
+    HttpAuth::Target target,
+    const GURL& origin,
+    CreateReason reason,
+    int digest_nonce_count,
+    const BoundNetLog& net_log,
+    scoped_ptr<HttpAuthHandler>* handler) {
+  // TODO(cbentzel): Move towards model of parsing in the factory
+  //                 method and only constructing when valid.
+  scoped_ptr<HttpAuthHandler> tmp_handler(new HttpAttestationHandler());
+  if (!tmp_handler->InitFromChallenge(challenge, target, origin, net_log))
+    return ERR_INVALID_RESPONSE;
+  handler->swap(tmp_handler);
+  return OK;
+}
+
+}  // namespace net
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
new file mode 100644
index 0000000..c1171c6
--- /dev/null
+++ b/net/http/http_attestation_handler.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
+#define NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
+
+#include <string>
+
+#include "net/base/net_export.h"
+#include "net/http/http_auth_handler.h"
+#include "net/http/http_auth_handler_factory.h"
+
+namespace net {
+
+// Code for handling http attestation challenge.
+class NET_EXPORT_PRIVATE HttpAttestationHandler : public HttpAuthHandler {
+ public:
+  class NET_EXPORT_PRIVATE Factory : public HttpAuthHandlerFactory {
+   public:
+    Factory();
+    virtual ~Factory();
+
+    virtual int CreateAuthHandler(
+        HttpAuthChallengeTokenizer* challenge,
+        HttpAuth::Target target,
+        const GURL& origin,
+        CreateReason reason,
+        int digest_nonce_count,
+        const BoundNetLog& net_log,
+        scoped_ptr<HttpAuthHandler>* handler) OVERRIDE;
+  };
+
+  virtual HttpAuth::AuthorizationResult HandleAnotherChallenge(
+      HttpAuthChallengeTokenizer* challenge) OVERRIDE;
+
+ protected:
+  virtual bool Init(HttpAuthChallengeTokenizer* challenge) OVERRIDE;
+
+  virtual int GenerateAuthTokenImpl(const AuthCredentials* credentials,
+                                    const HttpRequestInfo* request,
+                                    const CompletionCallback& callback,
+                                    std::string* auth_token) OVERRIDE;
+
+ private:
+  virtual ~HttpAttestationHandler() {}
+
+  bool ParseChallenge(HttpAuthChallengeTokenizer* challenge);
+};
+
+}  // namespace net
+
+#endif  // NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
diff --git a/net/http/http_auth.cc b/net/http/http_auth.cc
index 4c6d3e8..d9f442b 100644
--- a/net/http/http_auth.cc
+++ b/net/http/http_auth.cc
@@ -135,6 +135,7 @@ const char* HttpAuth::SchemeToString(Scheme scheme) {
     "ntlm",
     "negotiate",
     "spdyproxy",
+    "attestation",
     "mock",
   };
   COMPILE_ASSERT(arraysize(kSchemeNames) == AUTH_SCHEME_MAX,
diff --git a/net/http/http_auth.h b/net/http/http_auth.h
index 5a2c7ac..72c20f5 100644
--- a/net/http/http_auth.h
+++ b/net/http/http_auth.h
@@ -93,6 +93,7 @@ class NET_EXPORT_PRIVATE HttpAuth {
     AUTH_SCHEME_NTLM,
     AUTH_SCHEME_NEGOTIATE,
     AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_ATTESTATION,
     AUTH_SCHEME_MOCK,
     AUTH_SCHEME_MAX,
   };
diff --git a/net/http/http_auth_handler_factory.cc b/net/http/http_auth_handler_factory.cc
index 9867bb9..fef6d29 100644
--- a/net/http/http_auth_handler_factory.cc
+++ b/net/http/http_auth_handler_factory.cc
@@ -12,6 +12,7 @@
 #include "net/http/http_auth_handler_basic.h"
 #include "net/http/http_auth_handler_digest.h"
 #include "net/http/http_auth_handler_ntlm.h"
+#include "net/http/http_attestation_handler.h"
 
 #if defined(USE_KERBEROS)
 #include "net/http/http_auth_handler_negotiate.h"
@@ -52,6 +53,8 @@ HttpAuthHandlerRegistryFactory* HttpAuthHandlerFactory::CreateDefault(
       "basic", new HttpAuthHandlerBasic::Factory());
   registry_factory->RegisterSchemeFactory(
       "digest", new HttpAuthHandlerDigest::Factory());
+  registry_factory->RegisterSchemeFactory(
+      "attestation", new HttpAttestationHandler::Factory());
 
 #if defined(USE_KERBEROS)
   HttpAuthHandlerNegotiate::Factory* negotiate_factory =
@@ -141,6 +144,9 @@ HttpAuthHandlerRegistryFactory* HttpAuthHandlerRegistryFactory::Create(
   if (IsSupportedScheme(supported_schemes, "digest"))
     registry_factory->RegisterSchemeFactory(
         "digest", new HttpAuthHandlerDigest::Factory());
+  if (IsSupportedScheme(supported_schemes, "attestation"))
+    registry_factory->RegisterSchemeFactory(
+        "attestation", new HttpAttestationHandler::Factory());
   if (IsSupportedScheme(supported_schemes, "ntlm")) {
     HttpAuthHandlerNTLM::Factory* ntlm_factory =
         new HttpAuthHandlerNTLM::Factory();
diff --git a/net/net.gypi b/net/net.gypi
index cfa668a..e795baa 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -559,6 +559,8 @@
       'http/failing_http_transaction_factory.cc',
       'http/failing_http_transaction_factory.h',
       'http/http_atom_list.h',
+      'http/http_attestation_handler.cc',
+      'http/http_attestation_handler.h',
       'http/http_auth.cc',
       'http/http_auth.h',
       'http/http_auth_cache.cc',
-- 
1.7.10.2 (Apple Git-33)


From e7bbf48818e4d9a281bf619ed672dd4be63e294c Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 16:13:13 -0400
Subject: [PATCH 05/17] wasnt initializing this

---
 net/http/http_auth_controller.cc |    1 +
 1 file changed, 1 insertion(+)

diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index 9cc57de..ab4d553 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -512,6 +512,7 @@ void HttpAuthController::PopulateAuthChallenge() {
   auth_info_->challenger = HostPortPair::FromURL(auth_origin_);
   auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
   auth_info_->realm = handler_->realm();
+  auth_info_->is_attestation = false;
 }
 
 bool HttpAuthController::DisableOnAuthHandlerResult(int result) {
-- 
1.7.10.2 (Apple Git-33)


From aab9c098bc9e1880822e816ccab8192481844292 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 17:03:22 -0400
Subject: [PATCH 06/17] add request body to onAuthRequired call

---
 .../extensions/api/web_request/web_request_api.cc  |    3 +++
 chrome/common/extensions/api/web_request.json      |   28 ++++++++++++++++++--
 2 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/chrome/browser/extensions/api/web_request/web_request_api.cc b/chrome/browser/extensions/api/web_request/web_request_api.cc
index f3cd016..168e33c 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api.cc
@@ -938,6 +938,9 @@ ExtensionWebRequestEventRouter::OnAuthRequired(
     dict->Set(keys::kResponseHeadersKey,
               GetResponseHeadersList(request->response_headers()));
   }
+  if (extra_info_spec & ExtraInfoSpec::REQUEST_BODY) {
+    ExtractRequestInfoBody(request, dict);
+  }
   args.Append(dict);
 
   if (DispatchEvent(profile, request, listeners, args)) {
diff --git a/chrome/common/extensions/api/web_request.json b/chrome/common/extensions/api/web_request.json
index 5d279c7..9e0dead 100644
--- a/chrome/common/extensions/api/web_request.json
+++ b/chrome/common/extensions/api/web_request.json
@@ -339,7 +339,31 @@
               "challenger": {"type": "object", "description": "The server requesting authentication.", "properties": {"host": {"type": "string"}, "port": {"type": "integer"}}},
               "isProxy": {"type": "boolean", "description": "True for Proxy-Authenticate, false for WWW-Authenticate."},
               "responseHeaders": {"$ref": "HttpHeaders", "optional": true, "description": "The HTTP response headers that were received along with this response."},
-              "statusLine": {"type": "string", "description": "HTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers."}
+              "statusLine": {"type": "string", "description": "HTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers."},
+              "requestBody": {
+                "type": "object",
+                "optional": true,
+                "description": "Contains the HTTP request body data. Only provided if extraInfoSpec contains 'requestBody'.",
+                "properties": {
+                  "error": {"type": "string", "optional": true, "description": "Errors when obtaining request body data."},
+                  "formData": {
+                    "type": "object",
+                    "optional": true,
+                    "description": "If the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {'key': ['value1', 'value2']}.",
+                    "properties": {},
+                    "additionalProperties": {
+                      "type": "array",
+                      "items": { "type": "string" }
+                    }
+                  },
+                  "raw" : {
+                    "type": "array",
+                    "optional": true,
+                    "items": {"$ref": "UploadData"},
+                    "description": "If the request method is PUT or POST, and the body is not already parsed in formData, then the unparsed request body elements are contained in this array."
+                  }
+                }
+              }
             }
           },
           {
@@ -364,7 +388,7 @@
             "description": "Array of extra information that should be passed to the listener function.",
             "items": {
               "type": "string",
-              "enum": ["responseHeaders", "blocking", "asyncBlocking"]
+              "enum": ["responseHeaders", "blocking", "asyncBlocking", "requestBody"]
             }
           }
         ],
-- 
1.7.10.2 (Apple Git-33)


From 106d02f9c005b00ad0592a3115f30bfae7a1106d Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 17:33:25 -0400
Subject: [PATCH 07/17] possible added onAttestationRequired as proper event

---
 .../extensions/api/web_request/web_request_api.cc  |    1 +
 chrome/common/extensions/api/web_request.json      |   82 ++++++++++++++++++++
 2 files changed, 83 insertions(+)

diff --git a/chrome/browser/extensions/api/web_request/web_request_api.cc b/chrome/browser/extensions/api/web_request/web_request_api.cc
index 168e33c..0c63e57 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api.cc
@@ -103,6 +103,7 @@ const char* const kWebRequestEvents[] = {
   web_request::OnErrorOccurred::kEventName,
   keys::kOnSendHeadersEvent,
   keys::kOnAuthRequiredEvent,
+  keys::kOnAttestationRequiredEvent,
   keys::kOnResponseStartedEvent,
   keys::kOnHeadersReceivedEvent,
 };
diff --git a/chrome/common/extensions/api/web_request.json b/chrome/common/extensions/api/web_request.json
index 9e0dead..ea16865 100644
--- a/chrome/common/extensions/api/web_request.json
+++ b/chrome/common/extensions/api/web_request.json
@@ -399,6 +399,88 @@
         }
       },
       {
+        "name": "onAttestationRequired",
+        "nocompile": true,
+        "type": "function",
+        "description": "Fired when an attestation failure is received. The listener has three options: it can provide an attestation, it can cancel the request and display the error page, or it can take no action on the challenge. If a bad attestation is provided, this may be called multiple times for the same request.",
+        "parameters": [
+          {
+            "type": "object",
+            "name": "details",
+            "properties": {
+              "requestId": {"type": "string", "description": "The ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request."},
+              "url": {"type": "string"},
+              "method": {"type": "string", "description": "Standard HTTP method."},
+              "frameId": {"type": "integer", "description": "The value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (<code>type</code> is <code>main_frame</code> or <code>sub_frame</code>), <code>frameId</code> indicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab."},
+              "parentFrameId": {"type": "integer", "description": "ID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists."},
+              "tabId": {"type": "integer", "description": "The ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab."},
+              "type": {"type": "string", "enum": ["main_frame", "sub_frame", "stylesheet", "script", "image", "object", "xmlhttprequest", "other"], "description": "How the requested resource will be used."},
+              "timeStamp": {"type": "number", "description": "The time when this signal is triggered, in milliseconds since the epoch."},
+              "scheme": {"type": "string", "description": "The attestation scheme, e.g. Basic or Digest."},
+              "realm": {"type": "string", "description": "The attestation realm provided by the server, if there is one.", "optional": true},
+              "challenger": {"type": "object", "description": "The server requesting attestation.", "properties": {"host": {"type": "string"}, "port": {"type": "integer"}}},
+              "isProxy": {"type": "boolean", "description": "True for Proxy-Authenticate, false for WWW-Authenticate."},
+              "responseHeaders": {"$ref": "HttpHeaders", "optional": true, "description": "The HTTP response headers that were received along with this response."},
+              "statusLine": {"type": "string", "description": "HTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers."},
+              "requestBody": {
+                "type": "object",
+                "optional": true,
+                "description": "Contains the HTTP request body data. Only provided if extraInfoSpec contains 'requestBody'.",
+                "properties": {
+                  "error": {"type": "string", "optional": true, "description": "Errors when obtaining request body data."},
+                  "formData": {
+                    "type": "object",
+                    "optional": true,
+                    "description": "If the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {'key': ['value1', 'value2']}.",
+                    "properties": {},
+                    "additionalProperties": {
+                      "type": "array",
+                      "items": { "type": "string" }
+                    }
+                  },
+                  "raw" : {
+                    "type": "array",
+                    "optional": true,
+                    "items": {"$ref": "UploadData"},
+                    "description": "If the request method is PUT or POST, and the body is not already parsed in formData, then the unparsed request body elements are contained in this array."
+                  }
+                }
+              }
+            }
+          },
+          {
+            "type": "function",
+            "optional": true,
+            "name": "callback",
+            "parameters": [
+              {"name": "response", "$ref": "BlockingResponse"}
+            ]
+          }
+        ],
+        "extraParameters": [
+          {
+            "$ref": "RequestFilter",
+            "name": "filter",
+            "description": "A set of filters that restricts the events that will be sent to this listener."
+          },
+          {
+            "type": "array",
+            "optional": true,
+            "name": "extraInfoSpec",
+            "description": "Array of extra information that should be passed to the listener function.",
+            "items": {
+              "type": "string",
+              "enum": ["responseHeaders", "blocking", "asyncBlocking", "requestBody"]
+            }
+          }
+        ],
+        "returns": {
+          "$ref": "BlockingResponse",
+          "description": "If \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.",
+          "optional": true
+        }
+      },
+      {
         "name": "onResponseStarted",
         "nocompile": true,
         "type": "function",
-- 
1.7.10.2 (Apple Git-33)


From 7f5ea22a6096f75157e74d3c6acc414b4c003fc4 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 18:26:58 -0400
Subject: [PATCH 08/17] if hander returns true to IsAttestation, send to
 onAttestationRequired

---
 net/http/http_attestation_handler.cc |    4 ++++
 net/http/http_attestation_handler.h  |    2 ++
 net/http/http_auth_controller.cc     |    2 +-
 net/http/http_auth_handler.cc        |    4 ++++
 net/http/http_auth_handler.h         |    3 +++
 5 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
index 325bf6f..9135b67 100644
--- a/net/http/http_attestation_handler.cc
+++ b/net/http/http_attestation_handler.cc
@@ -39,6 +39,10 @@ HttpAuth::AuthorizationResult HttpAttestationHandler::HandleAnotherChallenge(
   return HttpAuth::AUTHORIZATION_RESULT_REJECT;
 }
 
+bool HttpAttestationHandler::IsAttestation() {
+  return true;
+}
+
 int HttpAttestationHandler::GenerateAuthTokenImpl(
     const AuthCredentials* credentials, const HttpRequestInfo*,
     const CompletionCallback&, std::string* auth_token) {
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
index c1171c6..611c6f4 100644
--- a/net/http/http_attestation_handler.h
+++ b/net/http/http_attestation_handler.h
@@ -34,6 +34,8 @@ class NET_EXPORT_PRIVATE HttpAttestationHandler : public HttpAuthHandler {
   virtual HttpAuth::AuthorizationResult HandleAnotherChallenge(
       HttpAuthChallengeTokenizer* challenge) OVERRIDE;
 
+  virtual bool IsAttestation() OVERRIDE;
+
  protected:
   virtual bool Init(HttpAuthChallengeTokenizer* challenge) OVERRIDE;
 
diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index ab4d553..5150c3d 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -512,7 +512,7 @@ void HttpAuthController::PopulateAuthChallenge() {
   auth_info_->challenger = HostPortPair::FromURL(auth_origin_);
   auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
   auth_info_->realm = handler_->realm();
-  auth_info_->is_attestation = false;
+  auth_info_->is_attestation = handler_->IsAttestation();
 }
 
 bool HttpAuthController::DisableOnAuthHandlerResult(int result) {
diff --git a/net/http/http_auth_handler.cc b/net/http/http_auth_handler.cc
index 7369ea5..959b8b4 100644
--- a/net/http/http_auth_handler.cc
+++ b/net/http/http_auth_handler.cc
@@ -93,6 +93,10 @@ bool HttpAuthHandler::AllowsExplicitCredentials() {
   return true;
 }
 
+bool HttpAuthHandler::IsAttestation() {
+  return false;
+}
+
 void HttpAuthHandler::OnGenerateAuthTokenComplete(int rv) {
   CompletionCallback callback = callback_;
   FinishGenerateAuthToken();
diff --git a/net/http/http_auth_handler.h b/net/http/http_auth_handler.h
index dfb50d4..9f63775 100644
--- a/net/http/http_auth_handler.h
+++ b/net/http/http_auth_handler.h
@@ -140,6 +140,9 @@ class NET_EXPORT_PRIVATE HttpAuthHandler {
   // cannot be determined.
   virtual bool AllowsExplicitCredentials();
 
+  // Returns whether this "auth handler" is actually an attestation handler
+  virtual bool IsAttestation();
+
  protected:
   enum Property {
     ENCRYPTS_IDENTITY = 1 << 0,
-- 
1.7.10.2 (Apple Git-33)


From c4478b33d59d89642313b9cf61245fee37cbe5ca Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 19:28:32 -0400
Subject: [PATCH 09/17] attestation_state_ to url_request_job

---
 net/url_request/url_request_http_job.cc |   27 +++++++++++++++++++--------
 net/url_request/url_request_http_job.h  |    3 ++-
 2 files changed, 21 insertions(+), 9 deletions(-)

diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index c5c209c..c1a9b0a 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -175,6 +175,7 @@ URLRequestHttpJob::URLRequestHttpJob(
       response_cookies_save_index_(0),
       proxy_auth_state_(AUTH_STATE_DONT_NEED_AUTH),
       server_auth_state_(AUTH_STATE_DONT_NEED_AUTH),
+      attestation_state_(AUTH_STATE_DONT_NEED_AUTH),
       start_callback_(base::Bind(&URLRequestHttpJob::OnStartCompleted,
                                  base::Unretained(this))),
       notify_before_headers_sent_callback_(
@@ -1080,6 +1081,11 @@ bool URLRequestHttpJob::NeedsAuth() {
         return false;
       server_auth_state_ = AUTH_STATE_NEED_AUTH;
       return true;
+    case 421:
+      if (attestation_state_ == AUTH_STATE_CANCELED)
+        return false;
+      attestation_state_ = AUTH_STATE_NEED_AUTH;
+      return true;
   }
   return false;
 }
@@ -1091,10 +1097,11 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 
   // sanity checks:
   DCHECK(proxy_auth_state_ == AUTH_STATE_NEED_AUTH ||
-         server_auth_state_ == AUTH_STATE_NEED_AUTH);
+         server_auth_state_ == AUTH_STATE_NEED_AUTH ||
+         attestation_state_ == AUTH_STATE_NEED_AUTH);
   DCHECK((GetResponseHeaders()->response_code() == HTTP_UNAUTHORIZED) ||
-         (GetResponseHeaders()->response_code() ==
-          HTTP_PROXY_AUTHENTICATION_REQUIRED));
+         (GetResponseHeaders()->response_code() == HTTP_PROXY_AUTHENTICATION_REQUIRED) ||
+         (GetResponseHeaders()->response_code() == HTTP_ATTESTATION_REQUIRED));
 
   *result = response_info_->auth_challenge;
 }
@@ -1102,12 +1109,14 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 void URLRequestHttpJob::SetAuth(const AuthCredentials& credentials) {
   DCHECK(transaction_.get());
 
-  // Proxy gets set first, then WWW.
+  // Proxy gets set first, then WWW, then attestation
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_HAVE_AUTH;
-  } else {
-    DCHECK_EQ(server_auth_state_, AUTH_STATE_NEED_AUTH);
+  } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
     server_auth_state_ = AUTH_STATE_HAVE_AUTH;
+  } else {
+    DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
+    attestation_state_ = AUTH_STATE_HAVE_AUTH;
   }
 
   RestartTransactionWithAuth(credentials);
@@ -1117,9 +1126,11 @@ void URLRequestHttpJob::CancelAuth() {
   // Proxy gets set first, then WWW.
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_CANCELED;
-  } else {
-    DCHECK_EQ(server_auth_state_, AUTH_STATE_NEED_AUTH);
+  } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
     server_auth_state_ = AUTH_STATE_CANCELED;
+  } else {
+    DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
+    attestation_state_ = AUTH_STATE_CANCELED;
   }
 
   // These will be reset in OnStartCompleted.
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index d5aa5ba..39c3071 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -180,9 +180,10 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
   size_t response_cookies_save_index_;
   base::Time response_date_;
 
-  // Auth states for proxy and origin server.
+  // Auth states for proxy and origin server and attestation.
   AuthState proxy_auth_state_;
   AuthState server_auth_state_;
+  AuthState attestation_state_;
   AuthCredentials auth_credentials_;
 
   CompletionCallback start_callback_;
-- 
1.7.10.2 (Apple Git-33)


From b035fbaf5b6179c730e6c396d3c4e266c8d9f1fc Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 22:54:03 -0400
Subject: [PATCH 10/17] working

---
 net/http/http_auth.cc                   |    6 ++++
 net/http/http_auth.h                    |    3 +-
 net/http/http_auth_controller.cc        |   20 ++++++++++++
 net/http/http_auth_handler.cc           |    2 ++
 net/http/http_auth_handler_basic.cc     |    1 +
 net/http/http_cache_transaction.cc      |    3 +-
 net/http/http_network_transaction.cc    |   54 ++++++++++++++++++++++++++++---
 net/http/http_network_transaction.h     |    4 +++
 net/http/http_request_headers.cc        |    1 +
 net/http/http_request_headers.h         |    1 +
 net/url_request/url_request_http_job.cc |    2 ++
 11 files changed, 91 insertions(+), 6 deletions(-)

diff --git a/net/http/http_auth.cc b/net/http/http_auth.cc
index d9f442b..e8a5dc8 100644
--- a/net/http/http_auth.cc
+++ b/net/http/http_auth.cc
@@ -95,6 +95,8 @@ std::string HttpAuth::GetChallengeHeaderName(Target target) {
       return "Proxy-Authenticate";
     case AUTH_SERVER:
       return "WWW-Authenticate";
+    case ATTESTATION:
+      return "Attestation-Challenge";
     default:
       NOTREACHED();
       return std::string();
@@ -108,6 +110,8 @@ std::string HttpAuth::GetAuthorizationHeaderName(Target target) {
       return HttpRequestHeaders::kProxyAuthorization;
     case AUTH_SERVER:
       return HttpRequestHeaders::kAuthorization;
+    case ATTESTATION:
+      return HttpRequestHeaders::kAttestation;
     default:
       NOTREACHED();
       return std::string();
@@ -121,6 +125,8 @@ std::string HttpAuth::GetAuthTargetString(Target target) {
       return "proxy";
     case AUTH_SERVER:
       return "server";
+    case ATTESTATION:
+      return "attestation";
     default:
       NOTREACHED();
       return std::string();
diff --git a/net/http/http_auth.h b/net/http/http_auth.h
index 72c20f5..4111cc5 100644
--- a/net/http/http_auth.h
+++ b/net/http/http_auth.h
@@ -33,7 +33,8 @@ class NET_EXPORT_PRIVATE HttpAuth {
     // in an array, so start from 0.
     AUTH_PROXY = 0,
     AUTH_SERVER = 1,
-    AUTH_NUM_TARGETS = 2,
+    ATTESTATION = 2,
+    AUTH_NUM_TARGETS = 3,
   };
 
   // What the HTTP WWW-Authenticate/Proxy-Authenticate headers indicate about
diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index 5150c3d..e7d27ad 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -41,6 +41,13 @@ std::string AuthChallengeLogMessage(HttpResponseHeaders* headers) {
     msg.append(header_val);
   }
 
+  // TODO change this header
+  iter = NULL;
+  while (headers->EnumerateHeader(&iter, "attestation-challenge", &header_val)) {
+    msg.append("\n  Has header Attestation-Challenge: ");
+    msg.append(header_val);
+  }
+
   // RFC 4559 requires that a proxy indicate its support of NTLM/Negotiate
   // authentication with a "Proxy-Support: Session-Based-Authentication"
   // response header.
@@ -64,6 +71,8 @@ enum AuthTarget {
   AUTH_TARGET_SECURE_PROXY,
   AUTH_TARGET_SERVER,
   AUTH_TARGET_SECURE_SERVER,
+  AUTH_TARGET_ATTESTATION,
+  AUTH_TARGET_SECURE_ATTESTATION,
   AUTH_TARGET_MAX,
 };
 
@@ -79,6 +88,11 @@ AuthTarget DetermineAuthTarget(const HttpAuthHandler* handler) {
         return AUTH_TARGET_SECURE_SERVER;
       else
         return AUTH_TARGET_SERVER;
+    case HttpAuth::ATTESTATION:
+      if (handler->origin().SchemeIsSecure())
+        return AUTH_TARGET_SECURE_ATTESTATION;
+      else
+        return AUTH_TARGET_ATTESTATION;
     default:
       NOTREACHED();
       return AUTH_TARGET_MAX;
@@ -112,6 +126,7 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   NTLM Reject: 5
   //   Negotiate Start: 6
   //   Negotiate Reject: 7
+  //   TODO: update this comment?
   static const int kEventBucketsEnd =
       HttpAuth::AUTH_SCHEME_MAX * AUTH_EVENT_MAX;
   int event_bucket = auth_scheme * AUTH_EVENT_MAX + auth_event;
@@ -138,6 +153,7 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   Negotiate Secure Proxy: 13
   //   Negotiate Server: 14
   //   Negotiate Secure Server: 15
+  //   TODO: update this comment?
   if (auth_event != AUTH_EVENT_START)
     return;
   static const int kTargetBucketsEnd =
@@ -164,6 +180,7 @@ HttpAuthController::HttpAuthController(
       default_credentials_used_(false),
       http_auth_cache_(http_auth_cache),
       http_auth_handler_factory_(http_auth_handler_factory) {
+  DVLOG(1) << "HttpAuthController BORN: " << HttpAuth::GetAuthTargetString(target);
 }
 
 HttpAuthController::~HttpAuthController() {
@@ -241,6 +258,7 @@ void HttpAuthController::AddAuthorizationHeader(
   if (!auth_token_.empty()) {
     authorization_headers->SetHeader(
         HttpAuth::GetAuthorizationHeaderName(target_), auth_token_);
+    DVLOG(1) << "Generating header " << HttpAuth::GetAuthorizationHeaderName(target_) << "=" << auth_token_;
     auth_token_.clear();
   }
 }
@@ -413,6 +431,8 @@ void HttpAuthController::ResetAuth(const AuthCredentials& credentials) {
     case HttpAuth::IDENT_SRC_DEFAULT_CREDENTIALS:
       break;
     default:
+      // TODO: skip cache for attestataion?
+      // changing challenge might take care of it.
       http_auth_cache_->Add(auth_origin_, handler_->realm(),
                             handler_->auth_scheme(), handler_->challenge(),
                             identity_.credentials, auth_path_);
diff --git a/net/http/http_auth_handler.cc b/net/http/http_auth_handler.cc
index 959b8b4..fe34205 100644
--- a/net/http/http_auth_handler.cc
+++ b/net/http/http_auth_handler.cc
@@ -52,6 +52,8 @@ NetLog::EventType EventTypeFromAuthTarget(HttpAuth::Target target) {
     case HttpAuth::AUTH_PROXY:
       return NetLog::TYPE_AUTH_PROXY;
     case HttpAuth::AUTH_SERVER:
+    case HttpAuth::ATTESTATION:
+      // TODO: should attestation have its own netlog?
       return NetLog::TYPE_AUTH_SERVER;
     default:
       NOTREACHED();
diff --git a/net/http/http_auth_handler_basic.cc b/net/http/http_auth_handler_basic.cc
index eace1df..4b04a96 100644
--- a/net/http/http_auth_handler_basic.cc
+++ b/net/http/http_auth_handler_basic.cc
@@ -95,6 +95,7 @@ int HttpAuthHandlerBasic::GenerateAuthTokenImpl(
                          base::UTF16ToUTF8(credentials->password()),
                      &base64_username_password);
   *auth_token = "Basic " + base64_username_password;
+  DVLOG(1) << "Basic HTTP Auth Handler set auth_token to: " << *auth_token;
   return OK;
 }
 
diff --git a/net/http/http_cache_transaction.cc b/net/http/http_cache_transaction.cc
index e2d46be..aef0bbe 100644
--- a/net/http/http_cache_transaction.cc
+++ b/net/http/http_cache_transaction.cc
@@ -958,7 +958,8 @@ int HttpCache::Transaction::DoSuccessfulSendRequest() {
   bool authentication_failure = false;
 
   if (new_response->headers->response_code() == 401 ||
-      new_response->headers->response_code() == 407) {
+      new_response->headers->response_code() == 407 ||
+      new_response->headers->response_code() == 421) {
     auth_response_ = *new_response;
     if (!reading_)
       return OK;
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index cf67b1d..6543a78 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -246,6 +246,7 @@ int HttpNetworkTransaction::RestartWithCertificate(
 
 int HttpNetworkTransaction::RestartWithAuth(
     const AuthCredentials& credentials, const CompletionCallback& callback) {
+  DVLOG(1) << "Restarting transaction with auth: " << credentials.username() << ":" << credentials.password();
   HttpAuth::Target target = pending_auth_target_;
   if (target == HttpAuth::AUTH_NONE) {
     NOTREACHED();
@@ -253,6 +254,7 @@ int HttpNetworkTransaction::RestartWithAuth(
   }
   pending_auth_target_ = HttpAuth::AUTH_NONE;
 
+  DVLOG(1) << "Pending Target is " << HttpAuth::GetAuthTargetString(target);
   auth_controllers_[target]->ResetAuth(credentials);
 
   DCHECK(callback_.is_null());
@@ -415,6 +417,7 @@ LoadState HttpNetworkTransaction::GetLoadState() const {
       return stream_request_->GetLoadState();
     case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:
     case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:
+    case STATE_GENERATE_ATTESTATION_COMPLETE:
     case STATE_SEND_REQUEST_COMPLETE:
       return LOAD_STATE_SENDING_REQUEST;
     case STATE_READ_HEADERS_COMPLETE:
@@ -641,6 +644,12 @@ int HttpNetworkTransaction::DoLoop(int result) {
       case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:
         rv = DoGenerateServerAuthTokenComplete(rv);
         break;
+      case STATE_GENERATE_ATTESTATION:
+        rv = DoGenerateAttestation();
+        break;
+      case STATE_GENERATE_ATTESTATION_COMPLETE:
+        rv = DoGenerateAttestationComplete(rv);
+        break;
       case STATE_INIT_REQUEST_BODY:
         DCHECK_EQ(OK, rv);
         rv = DoInitRequestBody();
@@ -831,6 +840,31 @@ int HttpNetworkTransaction::DoGenerateServerAuthToken() {
 int HttpNetworkTransaction::DoGenerateServerAuthTokenComplete(int rv) {
   DCHECK_NE(ERR_IO_PENDING, rv);
   if (rv == OK)
+    next_state_ = STATE_GENERATE_ATTESTATION;
+  return rv;
+}
+
+int HttpNetworkTransaction::DoGenerateAttestation() {
+  next_state_ = STATE_GENERATE_ATTESTATION_COMPLETE;
+  HttpAuth::Target target = HttpAuth::ATTESTATION;
+  if (!auth_controllers_[target].get()) {
+    auth_controllers_[target] =
+        new HttpAuthController(target,
+                               AuthURL(target),
+                               session_->http_auth_cache(),
+                               session_->http_auth_handler_factory());
+    if (request_->load_flags & LOAD_DO_NOT_USE_EMBEDDED_IDENTITY)
+      auth_controllers_[target]->DisableEmbeddedIdentity();
+  }
+
+  return auth_controllers_[target]->MaybeGenerateAuthToken(request_,
+                                                           io_callback_,
+                                                           net_log_);
+}
+
+int HttpNetworkTransaction::DoGenerateAttestationComplete(int rv) {
+  DCHECK_NE(ERR_IO_PENDING, rv);
+  if (rv == OK)
     next_state_ = STATE_INIT_REQUEST_BODY;
   return rv;
 }
@@ -880,11 +914,15 @@ void HttpNetworkTransaction::BuildRequestHeaders(bool using_proxy) {
   if (ShouldApplyServerAuth() && HaveAuth(HttpAuth::AUTH_SERVER))
     auth_controllers_[HttpAuth::AUTH_SERVER]->AddAuthorizationHeader(
         &request_headers_);
+  if (HaveAuth(HttpAuth::ATTESTATION))
+    auth_controllers_[HttpAuth::ATTESTATION]->AddAuthorizationHeader(
+        &request_headers_);
 
   request_headers_.MergeFrom(request_->extra_headers);
   response_.did_use_http_auth =
       request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) ||
       request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization);
+      // TODO: do I need to add to this...?
 }
 
 int HttpNetworkTransaction::DoInitRequestBody() {
@@ -1527,11 +1565,18 @@ int HttpNetworkTransaction::HandleAuthChallenge() {
   DCHECK(headers.get());
 
   int status = headers->response_code();
-  if (status != HTTP_UNAUTHORIZED &&
-      status != HTTP_PROXY_AUTHENTICATION_REQUIRED)
+  DVLOG(1) << "HandleAuthChallenge: " << status;
+  HttpAuth::Target target;
+  if (status == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
+    target = HttpAuth::AUTH_PROXY;
+  } else if (status == HTTP_UNAUTHORIZED) {
+    target = HttpAuth::AUTH_SERVER;
+  } else if (status == HTTP_ATTESTATION_REQUIRED) {
+    target = HttpAuth::ATTESTATION;
+  } else {
     return OK;
-  HttpAuth::Target target = status == HTTP_PROXY_AUTHENTICATION_REQUIRED ?
-                            HttpAuth::AUTH_PROXY : HttpAuth::AUTH_SERVER;
+  }
+
   if (target == HttpAuth::AUTH_PROXY && proxy_info_.is_direct())
     return ERR_UNEXPECTED_PROXY_AUTH;
 
@@ -1572,6 +1617,7 @@ GURL HttpNetworkTransaction::AuthURL(HttpAuth::Target target) const {
                   proxy_info_.proxy_server().host_port_pair().ToString());
     }
     case HttpAuth::AUTH_SERVER:
+    case HttpAuth::ATTESTATION:
       return request_->url;
     default:
      return GURL();
diff --git a/net/http/http_network_transaction.h b/net/http/http_network_transaction.h
index 24ab95b..610ad84 100644
--- a/net/http/http_network_transaction.h
+++ b/net/http/http_network_transaction.h
@@ -130,6 +130,8 @@ class NET_EXPORT_PRIVATE HttpNetworkTransaction
     STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE,
     STATE_GENERATE_SERVER_AUTH_TOKEN,
     STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE,
+    STATE_GENERATE_ATTESTATION,
+    STATE_GENERATE_ATTESTATION_COMPLETE,
     STATE_INIT_REQUEST_BODY,
     STATE_INIT_REQUEST_BODY_COMPLETE,
     STATE_BUILD_REQUEST,
@@ -166,6 +168,8 @@ class NET_EXPORT_PRIVATE HttpNetworkTransaction
   int DoGenerateProxyAuthTokenComplete(int result);
   int DoGenerateServerAuthToken();
   int DoGenerateServerAuthTokenComplete(int result);
+  int DoGenerateAttestation();
+  int DoGenerateAttestationComplete(int result);
   int DoInitRequestBody();
   int DoInitRequestBodyComplete(int result);
   int DoBuildRequest();
diff --git a/net/http/http_request_headers.cc b/net/http/http_request_headers.cc
index 9348e3e..e0e0ec1 100644
--- a/net/http/http_request_headers.cc
+++ b/net/http/http_request_headers.cc
@@ -19,6 +19,7 @@ const char HttpRequestHeaders::kAcceptCharset[] = "Accept-Charset";
 const char HttpRequestHeaders::kAcceptEncoding[] = "Accept-Encoding";
 const char HttpRequestHeaders::kAcceptLanguage[] = "Accept-Language";
 const char HttpRequestHeaders::kAuthorization[] = "Authorization";
+const char HttpRequestHeaders::kAttestation[] = "Attestation";
 const char HttpRequestHeaders::kCacheControl[] = "Cache-Control";
 const char HttpRequestHeaders::kConnection[] = "Connection";
 const char HttpRequestHeaders::kContentLength[] = "Content-Length";
diff --git a/net/http/http_request_headers.h b/net/http/http_request_headers.h
index 6178117..e03ec11 100644
--- a/net/http/http_request_headers.h
+++ b/net/http/http_request_headers.h
@@ -61,6 +61,7 @@ class NET_EXPORT HttpRequestHeaders {
   static const char kAcceptEncoding[];
   static const char kAcceptLanguage[];
   static const char kAuthorization[];
+  static const char kAttestation[];
   static const char kCacheControl[];
   static const char kConnection[];
   static const char kContentType[];
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index c1a9b0a..8f02462 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -1109,10 +1109,12 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 void URLRequestHttpJob::SetAuth(const AuthCredentials& credentials) {
   DCHECK(transaction_.get());
 
+  DVLOG(1) << "Setting Auth Credentials" << credentials.username() << " " << credentials.password();
   // Proxy gets set first, then WWW, then attestation
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_HAVE_AUTH;
   } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
+    DVLOG(1) << "To the Server";
     server_auth_state_ = AUTH_STATE_HAVE_AUTH;
   } else {
     DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
-- 
1.7.10.2 (Apple Git-33)


From f83e35de3851f1cb4e5f19e22926a1488d5cfa32 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 28 Apr 2014 23:10:10 -0400
Subject: [PATCH 11/17] another log

---
 net/http/http_auth_controller.cc |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index e7d27ad..0ec79a5 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -403,6 +403,8 @@ void HttpAuthController::ResetAuth(const AuthCredentials& credentials) {
   DCHECK(CalledOnValidThread());
   DCHECK(identity_.invalid || credentials.Empty());
 
+  DVLOG(1) << "Reset Auth called on controller " << this;
+
   if (identity_.invalid) {
     // Update the credentials.
     identity_.source = HttpAuth::IDENT_SRC_EXTERNAL;
-- 
1.7.10.2 (Apple Git-33)


From 095b1355c00e79f32277e7980288acfd15078f42 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Tue, 29 Apr 2014 01:33:20 -0400
Subject: [PATCH 12/17] in good shape

---
 net/http/http_auth.cc                 |   47 +++++++++++++++++++++++++++++++++
 net/http/http_auth.h                  |    3 +++
 net/http/http_auth_controller.cc      |    1 +
 net/http/http_auth_handler_factory.cc |   22 +++++++++++++++
 4 files changed, 73 insertions(+)

diff --git a/net/http/http_auth.cc b/net/http/http_auth.cc
index e8a5dc8..87f6ecf 100644
--- a/net/http/http_auth.cc
+++ b/net/http/http_auth.cc
@@ -134,6 +134,53 @@ std::string HttpAuth::GetAuthTargetString(Target target) {
 }
 
 // static
+std::vector<HttpAuth::Scheme> HttpAuth::GetSupportedSchemes(Target target) {
+  static const Scheme kServerSupportedSchemes[] = {
+    AUTH_SCHEME_BASIC,
+    AUTH_SCHEME_DIGEST,
+    AUTH_SCHEME_NTLM,
+    AUTH_SCHEME_NEGOTIATE,
+    AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kServerSupportedSchemeCount = 6;
+  COMPILE_ASSERT(arraysize(kServerSupportedSchemes) == kServerSupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  static const Scheme kProxySupportedSchemes[] = {
+    AUTH_SCHEME_BASIC,
+    AUTH_SCHEME_DIGEST,
+    AUTH_SCHEME_NTLM,
+    AUTH_SCHEME_NEGOTIATE,
+    AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kProxySupportedSchemeCount = 6;
+  COMPILE_ASSERT(arraysize(kProxySupportedSchemes) == kProxySupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  static const Scheme kAttestationSupportedSchemes[] = {
+    AUTH_SCHEME_ATTESTATION,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kAttestationSupportedSchemeCount = 2;
+  COMPILE_ASSERT(arraysize(kProxySupportedSchemes) == kProxySupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  switch (target) {
+    case AUTH_PROXY:
+      return std::vector<Scheme>(kProxySupportedSchemes, kProxySupportedSchemes + kProxySupportedSchemeCount);
+    case AUTH_SERVER:
+      return std::vector<Scheme>(kServerSupportedSchemes, kServerSupportedSchemes + kServerSupportedSchemeCount);
+    case ATTESTATION:
+      return std::vector<Scheme>(kAttestationSupportedSchemes, kAttestationSupportedSchemes + kAttestationSupportedSchemeCount);
+    default:
+      NOTREACHED();
+      return std::vector<Scheme>();
+  }
+}
+
+// static
 const char* HttpAuth::SchemeToString(Scheme scheme) {
   static const char* const kSchemeNames[] = {
     "basic",
diff --git a/net/http/http_auth.h b/net/http/http_auth.h
index 4111cc5..9b00a3c 100644
--- a/net/http/http_auth.h
+++ b/net/http/http_auth.h
@@ -121,6 +121,9 @@ class NET_EXPORT_PRIVATE HttpAuth {
   // messages.
   static std::string GetAuthTargetString(Target target);
 
+  // Returns vector of supported Schemes for given target;
+  static std::vector<Scheme> GetSupportedSchemes(Target target);
+
   // Returns a string representation of an authentication Scheme.
   static const char* SchemeToString(Scheme scheme);
 
diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index 0ec79a5..87572a0 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -197,6 +197,7 @@ int HttpAuthController::MaybeGenerateAuthToken(
   const AuthCredentials* credentials = NULL;
   if (identity_.source != HttpAuth::IDENT_SRC_DEFAULT_CREDENTIALS)
     credentials = &identity_.credentials;
+  DVLOG(1) << "Maybe generate " << this << identity_.source;
   DCHECK(auth_token_.empty());
   DCHECK(callback_.is_null());
   int rv = handler_->GenerateAuthToken(
diff --git a/net/http/http_auth_handler_factory.cc b/net/http/http_auth_handler_factory.cc
index fef6d29..9c99108 100644
--- a/net/http/http_auth_handler_factory.cc
+++ b/net/http/http_auth_handler_factory.cc
@@ -86,6 +86,23 @@ bool IsSupportedScheme(const std::vector<std::string>& supported_schemes,
   return it != supported_schemes.end();
 }
 
+bool IsSupportedSchemeForTarget(const std::string& scheme,
+                                HttpAuth::Target target) {
+
+  std::vector<HttpAuth::Scheme> supported_schemes = HttpAuth::GetSupportedSchemes(target);
+  std::vector<HttpAuth::Scheme>::iterator it = supported_schemes.begin();
+  bool found = false;
+  for (; it != supported_schemes.end(); ++it) {
+    DVLOG(1) << "Comparing " << scheme << " to " << HttpAuth::SchemeToString(*it);
+    if (LowerCaseEqualsASCII(scheme, HttpAuth::SchemeToString(*it))) {
+      found = true;
+    };
+  }
+  supported_schemes.erase(it);
+  supported_schemes.clear();
+  return found;
+}
+
 }  // namespace
 
 HttpAuthHandlerRegistryFactory::HttpAuthHandlerRegistryFactory() {
@@ -197,6 +214,11 @@ int HttpAuthHandlerRegistryFactory::CreateAuthHandler(
     handler->reset();
     return ERR_UNSUPPORTED_AUTH_SCHEME;
   }
+  DVLOG(1) << "Creating Auth Handler for target " << HttpAuth::GetAuthTargetString(target) << " for scheme " << lower_scheme;
+  if (!IsSupportedSchemeForTarget(lower_scheme, target)) {
+    handler->reset();
+    return ERR_UNSUPPORTED_AUTH_SCHEME;
+  }
   DCHECK(it->second);
   return it->second->CreateAuthHandler(challenge, target, origin, reason,
                                        digest_nonce_count, net_log, handler);
-- 
1.7.10.2 (Apple Git-33)


From a9da5edc64f65fccbd0f7d7e58059be2717e07ec Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Tue, 29 Apr 2014 01:46:40 -0400
Subject: [PATCH 13/17] clean up a bit

---
 net/http/http_auth_controller.cc        |   14 ++++----------
 net/http/http_auth_handler.cc           |    2 +-
 net/http/http_auth_handler_basic.cc     |    1 -
 net/http/http_auth_handler_factory.cc   |    3 +--
 net/http/http_network_transaction.cc    |    6 +-----
 net/url_request/url_request_http_job.cc |    2 --
 6 files changed, 7 insertions(+), 21 deletions(-)

diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index 87572a0..193d820 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -41,7 +41,6 @@ std::string AuthChallengeLogMessage(HttpResponseHeaders* headers) {
     msg.append(header_val);
   }
 
-  // TODO change this header
   iter = NULL;
   while (headers->EnumerateHeader(&iter, "attestation-challenge", &header_val)) {
     msg.append("\n  Has header Attestation-Challenge: ");
@@ -126,7 +125,8 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   NTLM Reject: 5
   //   Negotiate Start: 6
   //   Negotiate Reject: 7
-  //   TODO: update this comment?
+  //   TODO(sobel): update this comment?
+  //         because out of date from attestation
   static const int kEventBucketsEnd =
       HttpAuth::AUTH_SCHEME_MAX * AUTH_EVENT_MAX;
   int event_bucket = auth_scheme * AUTH_EVENT_MAX + auth_event;
@@ -153,7 +153,8 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   Negotiate Secure Proxy: 13
   //   Negotiate Server: 14
   //   Negotiate Secure Server: 15
-  //   TODO: update this comment?
+  //   TODO(sobel): update this comment?
+  //         because out of date from attestation
   if (auth_event != AUTH_EVENT_START)
     return;
   static const int kTargetBucketsEnd =
@@ -180,7 +181,6 @@ HttpAuthController::HttpAuthController(
       default_credentials_used_(false),
       http_auth_cache_(http_auth_cache),
       http_auth_handler_factory_(http_auth_handler_factory) {
-  DVLOG(1) << "HttpAuthController BORN: " << HttpAuth::GetAuthTargetString(target);
 }
 
 HttpAuthController::~HttpAuthController() {
@@ -197,7 +197,6 @@ int HttpAuthController::MaybeGenerateAuthToken(
   const AuthCredentials* credentials = NULL;
   if (identity_.source != HttpAuth::IDENT_SRC_DEFAULT_CREDENTIALS)
     credentials = &identity_.credentials;
-  DVLOG(1) << "Maybe generate " << this << identity_.source;
   DCHECK(auth_token_.empty());
   DCHECK(callback_.is_null());
   int rv = handler_->GenerateAuthToken(
@@ -259,7 +258,6 @@ void HttpAuthController::AddAuthorizationHeader(
   if (!auth_token_.empty()) {
     authorization_headers->SetHeader(
         HttpAuth::GetAuthorizationHeaderName(target_), auth_token_);
-    DVLOG(1) << "Generating header " << HttpAuth::GetAuthorizationHeaderName(target_) << "=" << auth_token_;
     auth_token_.clear();
   }
 }
@@ -404,8 +402,6 @@ void HttpAuthController::ResetAuth(const AuthCredentials& credentials) {
   DCHECK(CalledOnValidThread());
   DCHECK(identity_.invalid || credentials.Empty());
 
-  DVLOG(1) << "Reset Auth called on controller " << this;
-
   if (identity_.invalid) {
     // Update the credentials.
     identity_.source = HttpAuth::IDENT_SRC_EXTERNAL;
@@ -434,8 +430,6 @@ void HttpAuthController::ResetAuth(const AuthCredentials& credentials) {
     case HttpAuth::IDENT_SRC_DEFAULT_CREDENTIALS:
       break;
     default:
-      // TODO: skip cache for attestataion?
-      // changing challenge might take care of it.
       http_auth_cache_->Add(auth_origin_, handler_->realm(),
                             handler_->auth_scheme(), handler_->challenge(),
                             identity_.credentials, auth_path_);
diff --git a/net/http/http_auth_handler.cc b/net/http/http_auth_handler.cc
index fe34205..28f6d1d 100644
--- a/net/http/http_auth_handler.cc
+++ b/net/http/http_auth_handler.cc
@@ -53,7 +53,7 @@ NetLog::EventType EventTypeFromAuthTarget(HttpAuth::Target target) {
       return NetLog::TYPE_AUTH_PROXY;
     case HttpAuth::AUTH_SERVER:
     case HttpAuth::ATTESTATION:
-      // TODO: should attestation have its own netlog?
+      // TODO(sobel): should attestation have its own netlog?
       return NetLog::TYPE_AUTH_SERVER;
     default:
       NOTREACHED();
diff --git a/net/http/http_auth_handler_basic.cc b/net/http/http_auth_handler_basic.cc
index 4b04a96..eace1df 100644
--- a/net/http/http_auth_handler_basic.cc
+++ b/net/http/http_auth_handler_basic.cc
@@ -95,7 +95,6 @@ int HttpAuthHandlerBasic::GenerateAuthTokenImpl(
                          base::UTF16ToUTF8(credentials->password()),
                      &base64_username_password);
   *auth_token = "Basic " + base64_username_password;
-  DVLOG(1) << "Basic HTTP Auth Handler set auth_token to: " << *auth_token;
   return OK;
 }
 
diff --git a/net/http/http_auth_handler_factory.cc b/net/http/http_auth_handler_factory.cc
index 9c99108..3b5d127 100644
--- a/net/http/http_auth_handler_factory.cc
+++ b/net/http/http_auth_handler_factory.cc
@@ -93,9 +93,9 @@ bool IsSupportedSchemeForTarget(const std::string& scheme,
   std::vector<HttpAuth::Scheme>::iterator it = supported_schemes.begin();
   bool found = false;
   for (; it != supported_schemes.end(); ++it) {
-    DVLOG(1) << "Comparing " << scheme << " to " << HttpAuth::SchemeToString(*it);
     if (LowerCaseEqualsASCII(scheme, HttpAuth::SchemeToString(*it))) {
       found = true;
+      break;
     };
   }
   supported_schemes.erase(it);
@@ -214,7 +214,6 @@ int HttpAuthHandlerRegistryFactory::CreateAuthHandler(
     handler->reset();
     return ERR_UNSUPPORTED_AUTH_SCHEME;
   }
-  DVLOG(1) << "Creating Auth Handler for target " << HttpAuth::GetAuthTargetString(target) << " for scheme " << lower_scheme;
   if (!IsSupportedSchemeForTarget(lower_scheme, target)) {
     handler->reset();
     return ERR_UNSUPPORTED_AUTH_SCHEME;
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index 6543a78..147d4a5 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -246,15 +246,12 @@ int HttpNetworkTransaction::RestartWithCertificate(
 
 int HttpNetworkTransaction::RestartWithAuth(
     const AuthCredentials& credentials, const CompletionCallback& callback) {
-  DVLOG(1) << "Restarting transaction with auth: " << credentials.username() << ":" << credentials.password();
   HttpAuth::Target target = pending_auth_target_;
   if (target == HttpAuth::AUTH_NONE) {
     NOTREACHED();
     return ERR_UNEXPECTED;
   }
   pending_auth_target_ = HttpAuth::AUTH_NONE;
-
-  DVLOG(1) << "Pending Target is " << HttpAuth::GetAuthTargetString(target);
   auth_controllers_[target]->ResetAuth(credentials);
 
   DCHECK(callback_.is_null());
@@ -922,7 +919,7 @@ void HttpNetworkTransaction::BuildRequestHeaders(bool using_proxy) {
   response_.did_use_http_auth =
       request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) ||
       request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization);
-      // TODO: do I need to add to this...?
+      // TODO(sobel): do I need to add to this...?
 }
 
 int HttpNetworkTransaction::DoInitRequestBody() {
@@ -1565,7 +1562,6 @@ int HttpNetworkTransaction::HandleAuthChallenge() {
   DCHECK(headers.get());
 
   int status = headers->response_code();
-  DVLOG(1) << "HandleAuthChallenge: " << status;
   HttpAuth::Target target;
   if (status == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
     target = HttpAuth::AUTH_PROXY;
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index 8f02462..c1a9b0a 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -1109,12 +1109,10 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 void URLRequestHttpJob::SetAuth(const AuthCredentials& credentials) {
   DCHECK(transaction_.get());
 
-  DVLOG(1) << "Setting Auth Credentials" << credentials.username() << " " << credentials.password();
   // Proxy gets set first, then WWW, then attestation
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_HAVE_AUTH;
   } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
-    DVLOG(1) << "To the Server";
     server_auth_state_ = AUTH_STATE_HAVE_AUTH;
   } else {
     DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
-- 
1.7.10.2 (Apple Git-33)


From c08ed6611df61c67b4e56d6c512a64ba6217d1b8 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Tue, 29 Apr 2014 18:11:47 -0400
Subject: [PATCH 14/17] add attestation as a default supported scheme

---
 chrome/browser/io_thread.cc |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/chrome/browser/io_thread.cc b/chrome/browser/io_thread.cc
index 55b3f62..74cb0bb 100644
--- a/chrome/browser/io_thread.cc
+++ b/chrome/browser/io_thread.cc
@@ -866,7 +866,7 @@ void IOThread::EnableSpdy(const std::string& mode) {
 void IOThread::RegisterPrefs(PrefRegistrySimple* registry) {
   registry->RegisterStringPref(prefs::kAuthSchemes,
                                "basic,digest,ntlm,negotiate,"
-                               "spdyproxy");
+                               "spdyproxy,attestation");
   registry->RegisterBooleanPref(prefs::kDisableAuthNegotiateCnameLookup, false);
   registry->RegisterBooleanPref(prefs::kEnableAuthNegotiatePort, false);
   registry->RegisterStringPref(prefs::kAuthServerWhitelist, std::string());
-- 
1.7.10.2 (Apple Git-33)


From e2005fdf92994f3a2c49e282620f521ac86a52c1 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Tue, 29 Apr 2014 18:19:52 -0400
Subject: [PATCH 15/17] clean

---
 net/http/http_attestation_handler.cc |   63 ++++++++++++++++++++++++++++++++--
 net/http/http_attestation_handler.h  |    1 +
 2 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
index 9135b67..96f24d0 100644
--- a/net/http/http_attestation_handler.cc
+++ b/net/http/http_attestation_handler.cc
@@ -11,11 +11,70 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/net_errors.h"
+#include "net/base/upload_data_stream.h"
+#include "net/base/io_buffer.h"
 #include "net/http/http_auth.h"
 #include "net/http/http_auth_challenge_tokenizer.h"
+#include "net/http/http_request_info.h"
 
 namespace net {
 
+namespace {
+
+std::string GetRequestBodyDigest(const HttpRequestInfo* request) {
+  // TODO(sobel) currently only works if the upload_data_stream
+  // is not chunked! That's an issue...
+  // TODO(sobel) how do I handle this? crashing for now...
+
+  // Intialize MD5
+  base::MD5Context ctx;
+  base::MD5Init(&ctx);
+
+  size_t request_size;
+
+  if (NULL == request->upload_data_stream) {
+    // Then we have nothing to do.
+    request_size = 0;
+  } else {
+    // IsInMemory() ensures that the request body is not chunked (http_stream_parser.cc:1051)
+    DCHECK(request->upload_data_stream->IsInMemory());
+    request_size = request->upload_data_stream->size();
+  }
+
+  if (request_size > 0) {
+    scoped_refptr<IOBuffer> read_buffer_inner(new IOBuffer(request_size));
+    scoped_refptr<DrainableIOBuffer> read_buffer(new DrainableIOBuffer(read_buffer_inner.get(), request_size));
+
+    // Reset the upload data stream via an Init.
+    // TODO(sobel) who knows what kind of terrible affects this will have
+    // We know it will return syncrhonously because of the IsInMemory check
+    request->upload_data_stream->Init(CompletionCallback());
+
+    // Copied mostly from http_stream_parser.cc:267
+    size_t todo = request_size;
+    while (todo) {
+      // This will be sync because of the IsInMemory() check,
+      // so use a blank Callback
+      int consumed = request->upload_data_stream
+          ->Read(read_buffer.get(), todo, CompletionCallback());
+      DCHECK_GT(consumed, 0);  // Read() won't fail if not chunked.
+      // Update the digest
+      base::MD5Update(&ctx, base::StringPiece(read_buffer.get()->data(), consumed));
+      read_buffer->DidConsume(consumed);
+      todo -= consumed;
+    }
+  }
+
+  // Ok, now give give back the MD5Digest as a base16 string
+  base::MD5Digest digest;
+  base::MD5Final(&digest, &ctx);
+  std::string out = MD5DigestToBase16(digest);
+  DVLOG(1) << "Computed requestBody digest: " << out;
+  return out;
+}
+
+}
+
 bool HttpAttestationHandler::Init(HttpAuthChallengeTokenizer* challenge) {
   auth_scheme_ = HttpAuth::AUTH_SCHEME_ATTESTATION;
   score_ = 1;
@@ -44,7 +103,7 @@ bool HttpAttestationHandler::IsAttestation() {
 }
 
 int HttpAttestationHandler::GenerateAuthTokenImpl(
-    const AuthCredentials* credentials, const HttpRequestInfo*,
+    const AuthCredentials* credentials, const HttpRequestInfo* request,
     const CompletionCallback&, std::string* auth_token) {
   DCHECK(credentials);
   // TODO(eroman): is this the right encoding of username/password?
@@ -52,7 +111,7 @@ int HttpAttestationHandler::GenerateAuthTokenImpl(
   base::Base64Encode(base::UTF16ToUTF8(credentials->username()) + ":" +
                          base::UTF16ToUTF8(credentials->password()),
                      &base64_username_password);
-  *auth_token = "Basic " + base64_username_password;
+  *auth_token = "Basic " + base64_username_password + ":" + GetRequestBodyDigest(request);
   return OK;
 }
 
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
index 611c6f4..d9ac30c 100644
--- a/net/http/http_attestation_handler.h
+++ b/net/http/http_attestation_handler.h
@@ -7,6 +7,7 @@
 
 #include <string>
 
+#include "base/md5.h"
 #include "net/base/net_export.h"
 #include "net/http/http_auth_handler.h"
 #include "net/http/http_auth_handler_factory.h"
-- 
1.7.10.2 (Apple Git-33)


From f01736b09265a8bd979c372134c4bd7b4e5e3ca3 Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Wed, 30 Apr 2014 14:43:52 -0400
Subject: [PATCH 16/17] parse nonce

---
 net/http/http_attestation_handler.cc |   24 +++++++++++++++++++++++-
 net/http/http_attestation_handler.h  |    2 ++
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
index 96f24d0..9acb961 100644
--- a/net/http/http_attestation_handler.cc
+++ b/net/http/http_attestation_handler.cc
@@ -73,6 +73,23 @@ std::string GetRequestBodyDigest(const HttpRequestInfo* request) {
   return out;
 }
 
+// Gets the nonce out, returns false if cannot find one.
+bool ParseNonce(const HttpAuthChallengeTokenizer& tokenizer,
+                std::string* nonce) {
+  CHECK(nonce);
+  nonce->clear();
+  HttpUtil::NameValuePairsIterator parameters = tokenizer.param_pairs();
+  while (parameters.GetNext()) {
+    if (!LowerCaseEqualsASCII(parameters.name(), "nonce"))
+      continue;
+
+    *nonce = parameters.value();
+    return true;
+  }
+  return false;
+
+}
+
 }
 
 bool HttpAttestationHandler::Init(HttpAuthChallengeTokenizer* challenge) {
@@ -89,7 +106,12 @@ bool HttpAttestationHandler::ParseChallenge(
   if (!LowerCaseEqualsASCII(challenge->scheme(), "attestation"))
     return false;
 
-  realm_ = "attest/please";
+  std::string nonce;
+  if (!ParseNonce(*challenge, &nonce))
+    return false;
+
+  nonce_ = nonce;
+  realm_ = nonce;
   return true;
 }
 
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
index d9ac30c..29bcb32 100644
--- a/net/http/http_attestation_handler.h
+++ b/net/http/http_attestation_handler.h
@@ -49,6 +49,8 @@ class NET_EXPORT_PRIVATE HttpAttestationHandler : public HttpAuthHandler {
   virtual ~HttpAttestationHandler() {}
 
   bool ParseChallenge(HttpAuthChallengeTokenizer* challenge);
+
+  std::string nonce_;
 };
 
 }  // namespace net
-- 
1.7.10.2 (Apple Git-33)


From b1e038b01109108e93c3ff5f77ec61469251270b Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Wed, 30 Apr 2014 23:00:34 -0400
Subject: [PATCH 17/17] sha and rsa signature on Attestation

---
 net/http/http_attestation_handler.cc |  147 ++++++++++++++++++++++++++++++++--
 net/http/http_attestation_handler.h  |    3 +
 2 files changed, 143 insertions(+), 7 deletions(-)

diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
index 9acb961..b4632fc 100644
--- a/net/http/http_attestation_handler.cc
+++ b/net/http/http_attestation_handler.cc
@@ -21,7 +21,90 @@ namespace net {
 
 namespace {
 
-std::string GetRequestBodyDigest(const HttpRequestInfo* request) {
+static const uint8 kSigningPrivateKey[] = {
+  0x30, 0x82, 0x02, 0x7a, 0x02, 0x01, 0x00, 0x30,
+  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
+  0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82,
+  0x02, 0x64, 0x30, 0x82, 0x02, 0x60, 0x02, 0x01,
+  0x00, 0x02, 0x81, 0x81, 0x00, 0xbd, 0x51, 0x32,
+  0x9e, 0x85, 0x15, 0xe3, 0x4a, 0xdf, 0x0a, 0x10,
+  0x55, 0x35, 0xd1, 0x43, 0xf3, 0xa3, 0xfe, 0x61,
+  0xc1, 0xb4, 0x7e, 0xf3, 0xa4, 0xd2, 0x3b, 0xdf,
+  0xfc, 0xcf, 0x92, 0x3b, 0xc6, 0x73, 0x7a, 0x08,
+  0x36, 0xc0, 0x20, 0x09, 0x05, 0xf4, 0xae, 0x4c,
+  0x12, 0x49, 0x4e, 0xaf, 0x5b, 0x7d, 0xf8, 0x54,
+  0x4f, 0xe4, 0x5e, 0x20, 0xf0, 0x6f, 0xa7, 0xd4,
+  0xff, 0xf6, 0xad, 0xcb, 0xd3, 0xd6, 0xec, 0x86,
+  0x42, 0x3a, 0x34, 0x09, 0xe5, 0x42, 0x43, 0xef,
+  0x22, 0xe5, 0xc4, 0xb1, 0x31, 0x11, 0xf5, 0xe3,
+  0xf7, 0x71, 0x90, 0x71, 0xe0, 0x41, 0x6b, 0x7f,
+  0xac, 0xac, 0xcd, 0xfd, 0x83, 0x17, 0x62, 0x60,
+  0x89, 0x6c, 0xdb, 0x1c, 0x57, 0x4f, 0xb0, 0x7f,
+  0x60, 0xda, 0x74, 0x8b, 0xda, 0x19, 0x44, 0x00,
+  0xa6, 0x37, 0x36, 0x24, 0xd9, 0xdb, 0x61, 0x86,
+  0xd6, 0xd0, 0x56, 0xf1, 0x89, 0x02, 0x03, 0x01,
+  0x00, 0x01, 0x02, 0x81, 0x80, 0x74, 0x12, 0x35,
+  0x7b, 0xd5, 0x52, 0xdf, 0x21, 0x47, 0x70, 0x4f,
+  0x25, 0x3f, 0x32, 0xc7, 0x7b, 0xb8, 0x9f, 0x3d,
+  0x66, 0x5a, 0xf8, 0xbe, 0xfe, 0xdd, 0xda, 0xd1,
+  0xf0, 0x99, 0x7f, 0x29, 0xe0, 0xf9, 0x69, 0xe7,
+  0x61, 0x52, 0x18, 0x12, 0x10, 0x31, 0xbd, 0x2f,
+  0x6c, 0xc2, 0xbf, 0x58, 0x6a, 0x3a, 0xe8, 0xa7,
+  0x20, 0xb8, 0x7e, 0x31, 0xa9, 0xd8, 0x7b, 0x48,
+  0xef, 0x09, 0x53, 0x97, 0xa8, 0xfd, 0x15, 0xd1,
+  0x38, 0xe7, 0x06, 0x03, 0x22, 0x37, 0xd1, 0xc5,
+  0x5d, 0x42, 0x77, 0x25, 0x6e, 0x2b, 0xd2, 0xa1,
+  0x6c, 0xc6, 0x5b, 0xa7, 0x5e, 0x5a, 0x14, 0x5c,
+  0xb4, 0x9d, 0x09, 0xd6, 0x2b, 0x1f, 0x61, 0xaf,
+  0x75, 0xe1, 0xfb, 0x0a, 0x24, 0xc5, 0xa9, 0xf1,
+  0xaf, 0x6a, 0x30, 0xa7, 0x8b, 0x34, 0x67, 0x16,
+  0xd7, 0xf0, 0xad, 0xb5, 0x40, 0x8f, 0xeb, 0x3f,
+  0xd0, 0x08, 0x71, 0xe5, 0x01, 0x02, 0x45, 0x00,
+  0xd2, 0x71, 0x29, 0x6f, 0x76, 0x9f, 0xfa, 0xaf,
+  0x09, 0xa8, 0x9f, 0xbb, 0x22, 0x2f, 0xfc, 0x55,
+  0xf6, 0x62, 0x95, 0xa8, 0x0a, 0x05, 0xe9, 0x08,
+  0x62, 0xae, 0x81, 0xab, 0x14, 0x2f, 0x72, 0x36,
+  0x52, 0x02, 0x7e, 0xa0, 0x96, 0xc6, 0xe6, 0xe0,
+  0x33, 0xbc, 0x20, 0x0a, 0xfe, 0x11, 0x87, 0xf7,
+  0x35, 0x18, 0xf1, 0x92, 0x1d, 0x1c, 0x0f, 0x7b,
+  0x43, 0x86, 0x7c, 0x7f, 0x7c, 0xc6, 0xff, 0x45,
+  0xaf, 0xa1, 0xf7, 0xe9, 0x02, 0x3d, 0x00, 0xe6,
+  0x4d, 0x48, 0x34, 0x6a, 0x40, 0x4c, 0x07, 0x50,
+  0xb1, 0xa3, 0xb9, 0x30, 0x66, 0xe8, 0xc5, 0xfd,
+  0xaf, 0x1e, 0x02, 0x91, 0x50, 0x93, 0x53, 0xbf,
+  0x83, 0x8d, 0x12, 0xd9, 0x84, 0xaa, 0xde, 0x4a,
+  0xcb, 0x8f, 0x86, 0x3a, 0x45, 0xbe, 0x0b, 0x5c,
+  0x1a, 0x06, 0xa1, 0x55, 0xa9, 0xa8, 0x53, 0x74,
+  0xdb, 0x86, 0x09, 0x41, 0xd0, 0x42, 0x64, 0xaf,
+  0xec, 0xc8, 0xa1, 0x02, 0x44, 0x05, 0x3d, 0x8c,
+  0x2a, 0x9a, 0x69, 0xa1, 0x74, 0x7a, 0x69, 0x18,
+  0x91, 0x30, 0x68, 0xc1, 0x7f, 0xe2, 0x82, 0xd1,
+  0xf7, 0x3d, 0x48, 0xa8, 0x64, 0xed, 0x10, 0x2b,
+  0x6a, 0x77, 0x36, 0x37, 0x41, 0xe3, 0x08, 0xec,
+  0xde, 0x52, 0xe2, 0xe1, 0x1c, 0xf4, 0x2c, 0xdb,
+  0x1f, 0x6a, 0xf4, 0x44, 0xce, 0x83, 0x23, 0xfb,
+  0xe0, 0x07, 0x99, 0x8b, 0x49, 0x26, 0x85, 0x52,
+  0xd4, 0x59, 0xe7, 0x1a, 0xb4, 0x41, 0x8b, 0x67,
+  0x01, 0x02, 0x3c, 0x27, 0x00, 0xb1, 0x98, 0xc6,
+  0xe1, 0xca, 0xbe, 0x76, 0x69, 0x0f, 0x3c, 0x3e,
+  0xb9, 0x3e, 0xf4, 0xc1, 0x08, 0xd6, 0x41, 0x43,
+  0x10, 0xed, 0x52, 0x82, 0x9d, 0xa9, 0xd7, 0xa6,
+  0x64, 0xf4, 0x77, 0x1f, 0x1d, 0xa8, 0x59, 0xe8,
+  0x26, 0x85, 0x8f, 0xf0, 0xf2, 0x2b, 0x6b, 0x49,
+  0x51, 0xa9, 0x43, 0x31, 0x08, 0x38, 0x83, 0xfa,
+  0xd4, 0x65, 0x5a, 0x1d, 0xfd, 0x30, 0xe1, 0x02,
+  0x45, 0x00, 0x8e, 0xf0, 0xac, 0x9e, 0x71, 0xff,
+  0xb5, 0x86, 0xa6, 0xd1, 0x54, 0x61, 0x97, 0xf0,
+  0x60, 0xd5, 0xc0, 0x63, 0x2e, 0x11, 0x86, 0x74,
+  0x4e, 0x51, 0xdd, 0x5b, 0x13, 0xa2, 0x92, 0x89,
+  0xca, 0xa1, 0x25, 0x25, 0x06, 0xd9, 0x24, 0x4f,
+  0xe0, 0x62, 0xda, 0xdb, 0xd2, 0x74, 0xdd, 0xfd,
+  0xd3, 0xbc, 0xf2, 0xaf, 0xc9, 0xff, 0xfd, 0x4b,
+  0x1a, 0x70, 0x0a, 0xc2, 0xa3, 0x7a, 0x17, 0xad,
+  0x63, 0x1a, 0xf2, 0x29, 0x8b, 0x5f
+};
+
+void GetRequestBodyDigest(const HttpRequestInfo* request, std::string* request_body_digest) {
   // TODO(sobel) currently only works if the upload_data_stream
   // is not chunked! That's an issue...
   // TODO(sobel) how do I handle this? crashing for now...
@@ -70,7 +153,45 @@ std::string GetRequestBodyDigest(const HttpRequestInfo* request) {
   base::MD5Final(&digest, &ctx);
   std::string out = MD5DigestToBase16(digest);
   DVLOG(1) << "Computed requestBody digest: " << out;
-  return out;
+  *request_body_digest = out;
+}
+
+void GetAttestationAndSignature(std::string include_in_signature,
+                                std::string* attestation, std::string* signature) {
+
+  /* This function is the trusted computing base :/ */
+  // TODO(sobel) jank.
+
+  // TODO(sobel) get this from env at least
+  std::string working_attestation = "chrome";
+
+  // Now I need to sign it
+  std::string needs_signature = working_attestation + ":" + include_in_signature;
+  DVLOG(1) << "Attestation signing [" << needs_signature << "]";
+
+  std::vector<uint8> privKeyData(kSigningPrivateKey,
+    kSigningPrivateKey + sizeof(kSigningPrivateKey));
+
+  scoped_ptr<crypto::RSAPrivateKey> privKey(
+    crypto::RSAPrivateKey::CreateFromPrivateKeyInfo(privKeyData));
+  DCHECK(privKey.get()); // it better have worked!
+
+  scoped_ptr<crypto::SignatureCreator> signer(
+    crypto::SignatureCreator::Create(privKey.get()));
+
+  signer->Update(reinterpret_cast<const uint8*>(needs_signature.c_str()),
+    needs_signature.size());
+
+  std::vector<uint8> signatureBytes;
+  signer->Final(&signatureBytes);
+
+  // b64encode it.
+  std::string rsa_signature;
+  base::Base64Encode(base::StringPiece(reinterpret_cast<const char*>(&signatureBytes.front()),
+                     signatureBytes.size()), &rsa_signature);
+
+  *attestation = working_attestation;
+  *signature = rsa_signature;
 }
 
 // Gets the nonce out, returns false if cannot find one.
@@ -129,11 +250,23 @@ int HttpAttestationHandler::GenerateAuthTokenImpl(
     const CompletionCallback&, std::string* auth_token) {
   DCHECK(credentials);
   // TODO(eroman): is this the right encoding of username/password?
-  std::string base64_username_password;
-  base::Base64Encode(base::UTF16ToUTF8(credentials->username()) + ":" +
-                         base::UTF16ToUTF8(credentials->password()),
-                     &base64_username_password);
-  *auth_token = "Basic " + base64_username_password + ":" + GetRequestBodyDigest(request);
+
+  // credentials->password() will be application specific attestation
+  // (in this case, a digest of the page)
+  std::string extra_attestation;
+  base::Base64Encode(base::UTF16ToUTF8(credentials->password()), &extra_attestation);
+
+  std::string request_body_digest;
+  std::string attestation;
+  std::string signature;
+
+  // TODO(sobel) failure?
+  GetRequestBodyDigest(request, &request_body_digest);
+
+  std::string include_in_signature = extra_attestation + ":" + nonce_ + ":" + request_body_digest;
+  GetAttestationAndSignature(include_in_signature, &attestation, &signature);
+
+  *auth_token = attestation + ":" + extra_attestation + ":" + nonce_ + ":" + signature;
   return OK;
 }
 
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
index 29bcb32..7f003fc 100644
--- a/net/http/http_attestation_handler.h
+++ b/net/http/http_attestation_handler.h
@@ -8,6 +8,9 @@
 #include <string>
 
 #include "base/md5.h"
+#include "base/sha1.h"
+#include "crypto/rsa_private_key.h"
+#include "crypto/signature_creator.h"
 #include "net/base/net_export.h"
 #include "net/http/http_auth_handler.h"
 #include "net/http/http_auth_handler_factory.h"
-- 
1.7.10.2 (Apple Git-33)

