From 99ed0ed8bffb39e3b9324316923f2b3fe110952f Mon Sep 17 00:00:00 2001
From: Louis Sobel <sobel@mit.edu>
Date: Mon, 12 May 2014 01:32:52 -0400
Subject: [PATCH] Implement Remote Attestation In Chromium

---
 .../extensions/api/web_request/web_request_api.cc  |   18 +-
 .../extensions/api/web_request/web_request_api.h   |    7 +-
 .../api/web_request/web_request_api_constants.cc   |    2 +
 .../api/web_request/web_request_api_constants.h    |    2 +
 chrome/browser/io_thread.cc                        |    2 +-
 chrome/common/extensions/api/web_request.json      |   58 ++++
 net/base/auth.cc                                   |    3 +-
 net/base/auth.h                                    |    3 +
 net/http/http_attestation_handler.cc               |  302 ++++++++++++++++++++
 net/http/http_attestation_handler.h                |   61 ++++
 net/http/http_auth.cc                              |   54 ++++
 net/http/http_auth.h                               |    7 +-
 net/http/http_auth_controller.cc                   |   18 ++
 net/http/http_auth_handler.cc                      |    6 +
 net/http/http_auth_handler.h                       |    3 +
 net/http/http_auth_handler_factory.cc              |   27 ++
 net/http/http_cache_transaction.cc                 |    3 +-
 net/http/http_network_transaction.cc               |   52 +++-
 net/http/http_network_transaction.h                |    4 +
 net/http/http_request_headers.cc                   |    1 +
 net/http/http_request_headers.h                    |    1 +
 net/http/http_status_code_list.h                   |    1 +
 net/net.gypi                                       |    2 +
 net/url_request/url_request_http_job.cc            |   27 +-
 net/url_request/url_request_http_job.h             |    3 +-
 25 files changed, 642 insertions(+), 25 deletions(-)
 create mode 100644 net/http/http_attestation_handler.cc
 create mode 100644 net/http/http_attestation_handler.h

diff --git a/chrome/browser/extensions/api/web_request/web_request_api.cc b/chrome/browser/extensions/api/web_request/web_request_api.cc
index eef2a807..5d89a6a 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api.cc
@@ -103,6 +103,7 @@ const char* const kWebRequestEvents[] = {
   web_request::OnErrorOccurred::kEventName,
   keys::kOnSendHeadersEvent,
   keys::kOnAuthRequiredEvent,
+  keys::kOnAttestationRequiredEvent,
   keys::kOnResponseStartedEvent,
   keys::kOnHeadersReceivedEvent,
 };
@@ -126,6 +127,8 @@ const char* GetRequestStageAsString(
       return keys::kOnBeforeRedirect;
     case ExtensionWebRequestEventRouter::kOnAuthRequired:
       return keys::kOnAuthRequired;
+    case ExtensionWebRequestEventRouter::kOnAttestationRequired:
+      return keys::kOnAttestationRequired;
     case ExtensionWebRequestEventRouter::kOnResponseStarted:
       return keys::kOnResponseStarted;
     case ExtensionWebRequestEventRouter::kOnErrorOccurred:
@@ -905,10 +908,17 @@ ExtensionWebRequestEventRouter::OnAuthRequired(
     return net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_NO_ACTION;
 
   int extra_info_spec = 0;
-  std::vector<const EventListener*> listeners =
-      GetMatchingListeners(profile, extension_info_map,
-                           keys::kOnAuthRequiredEvent, request,
-                           &extra_info_spec);
+  std::vector<const EventListener*> listeners;
+  if (auth_info.is_attestation) {
+      listeners = GetMatchingListeners(profile, extension_info_map,
+                             keys::kOnAttestationRequiredEvent, request,
+                             &extra_info_spec);
+  } else {
+      listeners = GetMatchingListeners(profile, extension_info_map,
+                             keys::kOnAuthRequiredEvent, request,
+                             &extra_info_spec);
+  }
+
   if (listeners.empty())
     return net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_NO_ACTION;
 
diff --git a/chrome/browser/extensions/api/web_request/web_request_api.h b/chrome/browser/extensions/api/web_request/web_request_api.h
index 8a2795b..26848d9 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api.h
+++ b/chrome/browser/extensions/api/web_request/web_request_api.h
@@ -102,9 +102,10 @@ class ExtensionWebRequestEventRouter
     kOnHeadersReceived = 1 << 3,
     kOnBeforeRedirect = 1 << 4,
     kOnAuthRequired = 1 << 5,
-    kOnResponseStarted = 1 << 6,
-    kOnErrorOccurred = 1 << 7,
-    kOnCompleted = 1 << 8,
+    kOnAttestationRequired = 1 << 6,
+    kOnResponseStarted = 1 << 7,
+    kOnErrorOccurred = 1 << 8,
+    kOnCompleted = 1 << 9,
   };
 
   // Internal representation of the webRequest.RequestFilter type, used to
diff --git a/chrome/browser/extensions/api/web_request/web_request_api_constants.cc b/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
index aca996f..92f6402 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
+++ b/chrome/browser/extensions/api/web_request/web_request_api_constants.cc
@@ -50,6 +50,7 @@ const char kOnHeadersReceivedEvent[] = "webRequest.onHeadersReceived";
 const char kOnResponseStartedEvent[] = "webRequest.onResponseStarted";
 const char kOnSendHeadersEvent[] = "webRequest.onSendHeaders";
 const char kOnAuthRequiredEvent[] = "webRequest.onAuthRequired";
+const char kOnAttestationRequiredEvent[] = "webRequest.onAttestationRequired";
 
 const char kOnBeforeRedirect[] = "onBeforeRedirect";
 const char kOnBeforeRequest[] = "onBeforeRequest";
@@ -60,6 +61,7 @@ const char kOnHeadersReceived[] = "onHeadersReceived";
 const char kOnResponseStarted[] = "onResponseStarted";
 const char kOnSendHeaders[] = "onSendHeaders";
 const char kOnAuthRequired[] = "onAuthRequired";
+const char kOnAttestationRequired[] = "onAttestationRequired";
 
 const char kInvalidRedirectUrl[] = "redirectUrl '*' is not a valid URL.";
 const char kInvalidBlockingResponse[] =
diff --git a/chrome/browser/extensions/api/web_request/web_request_api_constants.h b/chrome/browser/extensions/api/web_request/web_request_api_constants.h
index 3dee75e..66f6577 100644
--- a/chrome/browser/extensions/api/web_request/web_request_api_constants.h
+++ b/chrome/browser/extensions/api/web_request/web_request_api_constants.h
@@ -51,6 +51,7 @@ extern const char kUsernameKey[];
 extern const char kPasswordKey[];
 
 // Events.
+extern const char kOnAttestationRequiredEvent[];
 extern const char kOnAuthRequiredEvent[];
 extern const char kOnBeforeRedirectEvent[];
 extern const char kOnBeforeRequestEvent[];
@@ -62,6 +63,7 @@ extern const char kOnResponseStartedEvent[];
 extern const char kOnSendHeadersEvent[];
 
 // Stages.
+extern const char kOnAttestationRequired[];
 extern const char kOnAuthRequired[];
 extern const char kOnBeforeRedirect[];
 extern const char kOnBeforeRequest[];
diff --git a/chrome/browser/io_thread.cc b/chrome/browser/io_thread.cc
index 29a65ea..ec38ecc 100644
--- a/chrome/browser/io_thread.cc
+++ b/chrome/browser/io_thread.cc
@@ -867,7 +867,7 @@ void IOThread::EnableSpdy(const std::string& mode) {
 void IOThread::RegisterPrefs(PrefRegistrySimple* registry) {
   registry->RegisterStringPref(prefs::kAuthSchemes,
                                "basic,digest,ntlm,negotiate,"
-                               "spdyproxy");
+                               "spdyproxy,attestation");
   registry->RegisterBooleanPref(prefs::kDisableAuthNegotiateCnameLookup, false);
   registry->RegisterBooleanPref(prefs::kEnableAuthNegotiatePort, false);
   registry->RegisterStringPref(prefs::kAuthServerWhitelist, std::string());
diff --git a/chrome/common/extensions/api/web_request.json b/chrome/common/extensions/api/web_request.json
index 5d279c7..e9588f4 100644
--- a/chrome/common/extensions/api/web_request.json
+++ b/chrome/common/extensions/api/web_request.json
@@ -375,6 +375,64 @@
         }
       },
       {
+        "name": "onAttestationRequired",
+        "nocompile": true,
+        "type": "function",
+        "description": "Fired when an attestation failure is received. The listener has three options: it can provide an attestation, it can cancel the request and display the error page, or it can take no action on the challenge. If a bad attestation is provided, this may be called multiple times for the same request.",
+        "parameters": [
+          {
+            "type": "object",
+            "name": "details",
+            "properties": {
+              "requestId": {"type": "string", "description": "The ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request."},
+              "url": {"type": "string"},
+              "method": {"type": "string", "description": "Standard HTTP method."},
+              "frameId": {"type": "integer", "description": "The value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (<code>type</code> is <code>main_frame</code> or <code>sub_frame</code>), <code>frameId</code> indicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab."},
+              "parentFrameId": {"type": "integer", "description": "ID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists."},
+              "tabId": {"type": "integer", "description": "The ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab."},
+              "type": {"type": "string", "enum": ["main_frame", "sub_frame", "stylesheet", "script", "image", "object", "xmlhttprequest", "other"], "description": "How the requested resource will be used."},
+              "timeStamp": {"type": "number", "description": "The time when this signal is triggered, in milliseconds since the epoch."},
+              "scheme": {"type": "string", "description": "The attestation scheme, e.g. Basic or Digest."},
+              "realm": {"type": "string", "description": "The attestation realm provided by the server, if there is one.", "optional": true},
+              "challenger": {"type": "object", "description": "The server requesting attestation.", "properties": {"host": {"type": "string"}, "port": {"type": "integer"}}},
+              "isProxy": {"type": "boolean", "description": "True for Proxy-Authenticate, false for WWW-Authenticate."},
+              "responseHeaders": {"$ref": "HttpHeaders", "optional": true, "description": "The HTTP response headers that were received along with this response."},
+              "statusLine": {"type": "string", "description": "HTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers."}
+            }
+          },
+          {
+            "type": "function",
+            "optional": true,
+            "name": "callback",
+            "parameters": [
+              {"name": "response", "$ref": "BlockingResponse"}
+            ]
+          }
+        ],
+        "extraParameters": [
+          {
+            "$ref": "RequestFilter",
+            "name": "filter",
+            "description": "A set of filters that restricts the events that will be sent to this listener."
+          },
+          {
+            "type": "array",
+            "optional": true,
+            "name": "extraInfoSpec",
+            "description": "Array of extra information that should be passed to the listener function.",
+            "items": {
+              "type": "string",
+              "enum": ["responseHeaders", "blocking", "asyncBlocking"]
+            }
+          }
+        ],
+        "returns": {
+          "$ref": "BlockingResponse",
+          "description": "If \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.",
+          "optional": true
+        }
+      },
+      {
         "name": "onResponseStarted",
         "nocompile": true,
         "type": "function",
diff --git a/net/base/auth.cc b/net/base/auth.cc
index 332e188..ade0851 100644
--- a/net/base/auth.cc
+++ b/net/base/auth.cc
@@ -14,7 +14,8 @@ bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {
   return (this->is_proxy == that.is_proxy &&
           this->challenger.Equals(that.challenger) &&
           this->scheme == that.scheme &&
-          this->realm == that.realm);
+          this->realm == that.realm &&
+          this->is_attestation == that.is_attestation);
 }
 
 AuthChallengeInfo::~AuthChallengeInfo() {
diff --git a/net/base/auth.h b/net/base/auth.h
index 62a59c8..9a162ba 100644
--- a/net/base/auth.h
+++ b/net/base/auth.h
@@ -30,6 +30,9 @@ class NET_EXPORT AuthChallengeInfo :
   // The service issuing the challenge.
   HostPortPair challenger;
 
+  // Is this an attestion request?
+  bool is_attestation;
+
   // The authentication scheme used, such as "basic" or "digest". If the
   // |source| is FTP_SERVER, this is an empty string. The encoding is ASCII.
   std::string scheme;
diff --git a/net/http/http_attestation_handler.cc b/net/http/http_attestation_handler.cc
new file mode 100644
index 0000000..cf39e32
--- /dev/null
+++ b/net/http/http_attestation_handler.cc
@@ -0,0 +1,302 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/http/http_attestation_handler.h"
+
+#include <string>
+
+#include "base/base64.h"
+#include "base/i18n/icu_string_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/net_errors.h"
+#include "net/base/upload_data_stream.h"
+#include "net/base/io_buffer.h"
+#include "net/http/http_auth.h"
+#include "net/http/http_auth_challenge_tokenizer.h"
+#include "net/http/http_request_info.h"
+
+namespace net {
+
+namespace {
+
+static const uint8 kSigningPrivateKey[] = {
+  0x30, 0x82, 0x02, 0x7a, 0x02, 0x01, 0x00, 0x30,
+  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
+  0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82,
+  0x02, 0x64, 0x30, 0x82, 0x02, 0x60, 0x02, 0x01,
+  0x00, 0x02, 0x81, 0x81, 0x00, 0xbd, 0x51, 0x32,
+  0x9e, 0x85, 0x15, 0xe3, 0x4a, 0xdf, 0x0a, 0x10,
+  0x55, 0x35, 0xd1, 0x43, 0xf3, 0xa3, 0xfe, 0x61,
+  0xc1, 0xb4, 0x7e, 0xf3, 0xa4, 0xd2, 0x3b, 0xdf,
+  0xfc, 0xcf, 0x92, 0x3b, 0xc6, 0x73, 0x7a, 0x08,
+  0x36, 0xc0, 0x20, 0x09, 0x05, 0xf4, 0xae, 0x4c,
+  0x12, 0x49, 0x4e, 0xaf, 0x5b, 0x7d, 0xf8, 0x54,
+  0x4f, 0xe4, 0x5e, 0x20, 0xf0, 0x6f, 0xa7, 0xd4,
+  0xff, 0xf6, 0xad, 0xcb, 0xd3, 0xd6, 0xec, 0x86,
+  0x42, 0x3a, 0x34, 0x09, 0xe5, 0x42, 0x43, 0xef,
+  0x22, 0xe5, 0xc4, 0xb1, 0x31, 0x11, 0xf5, 0xe3,
+  0xf7, 0x71, 0x90, 0x71, 0xe0, 0x41, 0x6b, 0x7f,
+  0xac, 0xac, 0xcd, 0xfd, 0x83, 0x17, 0x62, 0x60,
+  0x89, 0x6c, 0xdb, 0x1c, 0x57, 0x4f, 0xb0, 0x7f,
+  0x60, 0xda, 0x74, 0x8b, 0xda, 0x19, 0x44, 0x00,
+  0xa6, 0x37, 0x36, 0x24, 0xd9, 0xdb, 0x61, 0x86,
+  0xd6, 0xd0, 0x56, 0xf1, 0x89, 0x02, 0x03, 0x01,
+  0x00, 0x01, 0x02, 0x81, 0x80, 0x74, 0x12, 0x35,
+  0x7b, 0xd5, 0x52, 0xdf, 0x21, 0x47, 0x70, 0x4f,
+  0x25, 0x3f, 0x32, 0xc7, 0x7b, 0xb8, 0x9f, 0x3d,
+  0x66, 0x5a, 0xf8, 0xbe, 0xfe, 0xdd, 0xda, 0xd1,
+  0xf0, 0x99, 0x7f, 0x29, 0xe0, 0xf9, 0x69, 0xe7,
+  0x61, 0x52, 0x18, 0x12, 0x10, 0x31, 0xbd, 0x2f,
+  0x6c, 0xc2, 0xbf, 0x58, 0x6a, 0x3a, 0xe8, 0xa7,
+  0x20, 0xb8, 0x7e, 0x31, 0xa9, 0xd8, 0x7b, 0x48,
+  0xef, 0x09, 0x53, 0x97, 0xa8, 0xfd, 0x15, 0xd1,
+  0x38, 0xe7, 0x06, 0x03, 0x22, 0x37, 0xd1, 0xc5,
+  0x5d, 0x42, 0x77, 0x25, 0x6e, 0x2b, 0xd2, 0xa1,
+  0x6c, 0xc6, 0x5b, 0xa7, 0x5e, 0x5a, 0x14, 0x5c,
+  0xb4, 0x9d, 0x09, 0xd6, 0x2b, 0x1f, 0x61, 0xaf,
+  0x75, 0xe1, 0xfb, 0x0a, 0x24, 0xc5, 0xa9, 0xf1,
+  0xaf, 0x6a, 0x30, 0xa7, 0x8b, 0x34, 0x67, 0x16,
+  0xd7, 0xf0, 0xad, 0xb5, 0x40, 0x8f, 0xeb, 0x3f,
+  0xd0, 0x08, 0x71, 0xe5, 0x01, 0x02, 0x45, 0x00,
+  0xd2, 0x71, 0x29, 0x6f, 0x76, 0x9f, 0xfa, 0xaf,
+  0x09, 0xa8, 0x9f, 0xbb, 0x22, 0x2f, 0xfc, 0x55,
+  0xf6, 0x62, 0x95, 0xa8, 0x0a, 0x05, 0xe9, 0x08,
+  0x62, 0xae, 0x81, 0xab, 0x14, 0x2f, 0x72, 0x36,
+  0x52, 0x02, 0x7e, 0xa0, 0x96, 0xc6, 0xe6, 0xe0,
+  0x33, 0xbc, 0x20, 0x0a, 0xfe, 0x11, 0x87, 0xf7,
+  0x35, 0x18, 0xf1, 0x92, 0x1d, 0x1c, 0x0f, 0x7b,
+  0x43, 0x86, 0x7c, 0x7f, 0x7c, 0xc6, 0xff, 0x45,
+  0xaf, 0xa1, 0xf7, 0xe9, 0x02, 0x3d, 0x00, 0xe6,
+  0x4d, 0x48, 0x34, 0x6a, 0x40, 0x4c, 0x07, 0x50,
+  0xb1, 0xa3, 0xb9, 0x30, 0x66, 0xe8, 0xc5, 0xfd,
+  0xaf, 0x1e, 0x02, 0x91, 0x50, 0x93, 0x53, 0xbf,
+  0x83, 0x8d, 0x12, 0xd9, 0x84, 0xaa, 0xde, 0x4a,
+  0xcb, 0x8f, 0x86, 0x3a, 0x45, 0xbe, 0x0b, 0x5c,
+  0x1a, 0x06, 0xa1, 0x55, 0xa9, 0xa8, 0x53, 0x74,
+  0xdb, 0x86, 0x09, 0x41, 0xd0, 0x42, 0x64, 0xaf,
+  0xec, 0xc8, 0xa1, 0x02, 0x44, 0x05, 0x3d, 0x8c,
+  0x2a, 0x9a, 0x69, 0xa1, 0x74, 0x7a, 0x69, 0x18,
+  0x91, 0x30, 0x68, 0xc1, 0x7f, 0xe2, 0x82, 0xd1,
+  0xf7, 0x3d, 0x48, 0xa8, 0x64, 0xed, 0x10, 0x2b,
+  0x6a, 0x77, 0x36, 0x37, 0x41, 0xe3, 0x08, 0xec,
+  0xde, 0x52, 0xe2, 0xe1, 0x1c, 0xf4, 0x2c, 0xdb,
+  0x1f, 0x6a, 0xf4, 0x44, 0xce, 0x83, 0x23, 0xfb,
+  0xe0, 0x07, 0x99, 0x8b, 0x49, 0x26, 0x85, 0x52,
+  0xd4, 0x59, 0xe7, 0x1a, 0xb4, 0x41, 0x8b, 0x67,
+  0x01, 0x02, 0x3c, 0x27, 0x00, 0xb1, 0x98, 0xc6,
+  0xe1, 0xca, 0xbe, 0x76, 0x69, 0x0f, 0x3c, 0x3e,
+  0xb9, 0x3e, 0xf4, 0xc1, 0x08, 0xd6, 0x41, 0x43,
+  0x10, 0xed, 0x52, 0x82, 0x9d, 0xa9, 0xd7, 0xa6,
+  0x64, 0xf4, 0x77, 0x1f, 0x1d, 0xa8, 0x59, 0xe8,
+  0x26, 0x85, 0x8f, 0xf0, 0xf2, 0x2b, 0x6b, 0x49,
+  0x51, 0xa9, 0x43, 0x31, 0x08, 0x38, 0x83, 0xfa,
+  0xd4, 0x65, 0x5a, 0x1d, 0xfd, 0x30, 0xe1, 0x02,
+  0x45, 0x00, 0x8e, 0xf0, 0xac, 0x9e, 0x71, 0xff,
+  0xb5, 0x86, 0xa6, 0xd1, 0x54, 0x61, 0x97, 0xf0,
+  0x60, 0xd5, 0xc0, 0x63, 0x2e, 0x11, 0x86, 0x74,
+  0x4e, 0x51, 0xdd, 0x5b, 0x13, 0xa2, 0x92, 0x89,
+  0xca, 0xa1, 0x25, 0x25, 0x06, 0xd9, 0x24, 0x4f,
+  0xe0, 0x62, 0xda, 0xdb, 0xd2, 0x74, 0xdd, 0xfd,
+  0xd3, 0xbc, 0xf2, 0xaf, 0xc9, 0xff, 0xfd, 0x4b,
+  0x1a, 0x70, 0x0a, 0xc2, 0xa3, 0x7a, 0x17, 0xad,
+  0x63, 0x1a, 0xf2, 0x29, 0x8b, 0x5f
+};
+
+void GetRequestDigest(const HttpRequestInfo* request, std::string* request_digest) {
+  // TODO(sobel) currently only works if the upload_data_stream
+  // is not chunked! That's an issue...
+  // TODO(sobel) how do I handle this? crashing for now...
+
+  // Intialize MD5
+  base::MD5Context ctx;
+  base::MD5Init(&ctx);
+
+  // method : url : body
+  base::MD5Update(&ctx, request->method);
+  base::MD5Update(&ctx, ":");
+  base::MD5Update(&ctx, request->url.PathForRequest());
+  base::MD5Update(&ctx, ":");
+
+  size_t request_size;
+
+  if (NULL == request->upload_data_stream) {
+    // Then we have nothing to do.
+    request_size = 0;
+  } else {
+    // IsInMemory() ensures that the request body is not chunked (http_stream_parser.cc:1051)
+    DCHECK(request->upload_data_stream->IsInMemory());
+    request_size = request->upload_data_stream->size();
+  }
+
+  if (request_size > 0) {
+    scoped_refptr<IOBuffer> read_buffer_inner(new IOBuffer(request_size));
+    scoped_refptr<DrainableIOBuffer> read_buffer(new DrainableIOBuffer(read_buffer_inner.get(), request_size));
+
+    // Reset the upload data stream via an Init.
+    // TODO(sobel) who knows what kind of terrible affects this will have
+    // We know it will return syncrhonously because of the IsInMemory check
+    request->upload_data_stream->Init(CompletionCallback());
+
+    // Copied mostly from http_stream_parser.cc:267
+    size_t todo = request_size;
+    while (todo) {
+      // This will be sync because of the IsInMemory() check,
+      // so use a blank Callback
+      int consumed = request->upload_data_stream
+          ->Read(read_buffer.get(), todo, CompletionCallback());
+      DCHECK_GT(consumed, 0);  // Read() won't fail if not chunked.
+      // Update the digest
+      base::MD5Update(&ctx, base::StringPiece(read_buffer.get()->data(), consumed));
+      read_buffer->DidConsume(consumed);
+      todo -= consumed;
+    }
+  }
+
+  // Ok, now give give back the MD5Digest as a base16 string
+  base::MD5Digest digest;
+  base::MD5Final(&digest, &ctx);
+  std::string out = MD5DigestToBase16(digest);
+  DVLOG(1) << "Computed request digest: " << out;
+  *request_digest = out;
+}
+
+void GetAttestationAndSignature(std::string include_in_signature,
+                                std::string* attestation, std::string* signature) {
+
+  /* This function is the trusted computing base :/ */
+  // TODO(sobel) jank.
+
+  // TODO(sobel) get this from env at least
+  std::string working_attestation = "chrome";
+
+  // Now I need to sign it
+  std::string needs_signature = working_attestation + ":" + include_in_signature;
+  DVLOG(1) << "Attestation signing [" << needs_signature << "]";
+
+  std::vector<uint8> privKeyData(kSigningPrivateKey,
+    kSigningPrivateKey + sizeof(kSigningPrivateKey));
+
+  scoped_ptr<crypto::RSAPrivateKey> privKey(
+    crypto::RSAPrivateKey::CreateFromPrivateKeyInfo(privKeyData));
+  DCHECK(privKey.get()); // it better have worked!
+
+  scoped_ptr<crypto::SignatureCreator> signer(
+    crypto::SignatureCreator::Create(privKey.get()));
+
+  signer->Update(reinterpret_cast<const uint8*>(needs_signature.c_str()),
+    needs_signature.size());
+
+  std::vector<uint8> signatureBytes;
+  signer->Final(&signatureBytes);
+
+  // b64encode it.
+  std::string rsa_signature;
+  base::Base64Encode(base::StringPiece(reinterpret_cast<const char*>(&signatureBytes.front()),
+                     signatureBytes.size()), &rsa_signature);
+
+  *attestation = working_attestation;
+  *signature = rsa_signature;
+}
+
+// Gets the nonce out, returns false if cannot find one.
+bool ParseNonce(const HttpAuthChallengeTokenizer& tokenizer,
+                std::string* nonce) {
+  CHECK(nonce);
+  nonce->clear();
+  HttpUtil::NameValuePairsIterator parameters = tokenizer.param_pairs();
+  while (parameters.GetNext()) {
+    if (!LowerCaseEqualsASCII(parameters.name(), "nonce"))
+      continue;
+
+    *nonce = parameters.value();
+    return true;
+  }
+  return false;
+
+}
+
+}
+
+bool HttpAttestationHandler::Init(HttpAuthChallengeTokenizer* challenge) {
+  auth_scheme_ = HttpAuth::AUTH_SCHEME_ATTESTATION;
+  score_ = 1;
+  properties_ = 0;
+  return ParseChallenge(challenge);
+}
+
+bool HttpAttestationHandler::ParseChallenge(
+    HttpAuthChallengeTokenizer* challenge) {
+
+  // Verify the challenge's auth-scheme.
+  if (!LowerCaseEqualsASCII(challenge->scheme(), "attestation"))
+    return false;
+
+  std::string nonce;
+  if (!ParseNonce(*challenge, &nonce))
+    return false;
+
+  nonce_ = nonce;
+  realm_ = nonce;
+  return true;
+}
+
+HttpAuth::AuthorizationResult HttpAttestationHandler::HandleAnotherChallenge(
+    HttpAuthChallengeTokenizer* challenge) {
+  return HttpAuth::AUTHORIZATION_RESULT_REJECT;
+}
+
+bool HttpAttestationHandler::IsAttestation() {
+  return true;
+}
+
+int HttpAttestationHandler::GenerateAuthTokenImpl(
+    const AuthCredentials* credentials, const HttpRequestInfo* request,
+    const CompletionCallback&, std::string* auth_token) {
+  DCHECK(credentials);
+  // TODO(eroman): is this the right encoding of username/password?
+
+  // credentials->password() will be application specific attestation
+  // (in this case, a digest of the page)
+  std::string extra_attestation;
+  base::Base64Encode(base::UTF16ToUTF8(credentials->password()), &extra_attestation);
+
+  std::string request_digest;
+  std::string attestation;
+  std::string signature;
+
+  // TODO(sobel) failure?
+  GetRequestDigest(request, &request_digest);
+
+  std::string include_in_signature = extra_attestation + ":" + nonce_ + ":" + request_digest;
+  GetAttestationAndSignature(include_in_signature, &attestation, &signature);
+
+  *auth_token = attestation + ":" + extra_attestation + ":" + nonce_ + ":" + signature;
+  return OK;
+}
+
+HttpAttestationHandler::Factory::Factory() {
+}
+
+HttpAttestationHandler::Factory::~Factory() {
+}
+
+int HttpAttestationHandler::Factory::CreateAuthHandler(
+    HttpAuthChallengeTokenizer* challenge,
+    HttpAuth::Target target,
+    const GURL& origin,
+    CreateReason reason,
+    int digest_nonce_count,
+    const BoundNetLog& net_log,
+    scoped_ptr<HttpAuthHandler>* handler) {
+  // TODO(cbentzel): Move towards model of parsing in the factory
+  //                 method and only constructing when valid.
+  scoped_ptr<HttpAuthHandler> tmp_handler(new HttpAttestationHandler());
+  if (!tmp_handler->InitFromChallenge(challenge, target, origin, net_log))
+    return ERR_INVALID_RESPONSE;
+  handler->swap(tmp_handler);
+  return OK;
+}
+
+}  // namespace net
diff --git a/net/http/http_attestation_handler.h b/net/http/http_attestation_handler.h
new file mode 100644
index 0000000..7f003fc
--- /dev/null
+++ b/net/http/http_attestation_handler.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
+#define NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
+
+#include <string>
+
+#include "base/md5.h"
+#include "base/sha1.h"
+#include "crypto/rsa_private_key.h"
+#include "crypto/signature_creator.h"
+#include "net/base/net_export.h"
+#include "net/http/http_auth_handler.h"
+#include "net/http/http_auth_handler_factory.h"
+
+namespace net {
+
+// Code for handling http attestation challenge.
+class NET_EXPORT_PRIVATE HttpAttestationHandler : public HttpAuthHandler {
+ public:
+  class NET_EXPORT_PRIVATE Factory : public HttpAuthHandlerFactory {
+   public:
+    Factory();
+    virtual ~Factory();
+
+    virtual int CreateAuthHandler(
+        HttpAuthChallengeTokenizer* challenge,
+        HttpAuth::Target target,
+        const GURL& origin,
+        CreateReason reason,
+        int digest_nonce_count,
+        const BoundNetLog& net_log,
+        scoped_ptr<HttpAuthHandler>* handler) OVERRIDE;
+  };
+
+  virtual HttpAuth::AuthorizationResult HandleAnotherChallenge(
+      HttpAuthChallengeTokenizer* challenge) OVERRIDE;
+
+  virtual bool IsAttestation() OVERRIDE;
+
+ protected:
+  virtual bool Init(HttpAuthChallengeTokenizer* challenge) OVERRIDE;
+
+  virtual int GenerateAuthTokenImpl(const AuthCredentials* credentials,
+                                    const HttpRequestInfo* request,
+                                    const CompletionCallback& callback,
+                                    std::string* auth_token) OVERRIDE;
+
+ private:
+  virtual ~HttpAttestationHandler() {}
+
+  bool ParseChallenge(HttpAuthChallengeTokenizer* challenge);
+
+  std::string nonce_;
+};
+
+}  // namespace net
+
+#endif  // NET_HTTP_HTTP_ATTESTATION_HANDLER_H_
diff --git a/net/http/http_auth.cc b/net/http/http_auth.cc
index 4c6d3e8..87f6ecf 100644
--- a/net/http/http_auth.cc
+++ b/net/http/http_auth.cc
@@ -95,6 +95,8 @@ std::string HttpAuth::GetChallengeHeaderName(Target target) {
       return "Proxy-Authenticate";
     case AUTH_SERVER:
       return "WWW-Authenticate";
+    case ATTESTATION:
+      return "Attestation-Challenge";
     default:
       NOTREACHED();
       return std::string();
@@ -108,6 +110,8 @@ std::string HttpAuth::GetAuthorizationHeaderName(Target target) {
       return HttpRequestHeaders::kProxyAuthorization;
     case AUTH_SERVER:
       return HttpRequestHeaders::kAuthorization;
+    case ATTESTATION:
+      return HttpRequestHeaders::kAttestation;
     default:
       NOTREACHED();
       return std::string();
@@ -121,6 +125,8 @@ std::string HttpAuth::GetAuthTargetString(Target target) {
       return "proxy";
     case AUTH_SERVER:
       return "server";
+    case ATTESTATION:
+      return "attestation";
     default:
       NOTREACHED();
       return std::string();
@@ -128,6 +134,53 @@ std::string HttpAuth::GetAuthTargetString(Target target) {
 }
 
 // static
+std::vector<HttpAuth::Scheme> HttpAuth::GetSupportedSchemes(Target target) {
+  static const Scheme kServerSupportedSchemes[] = {
+    AUTH_SCHEME_BASIC,
+    AUTH_SCHEME_DIGEST,
+    AUTH_SCHEME_NTLM,
+    AUTH_SCHEME_NEGOTIATE,
+    AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kServerSupportedSchemeCount = 6;
+  COMPILE_ASSERT(arraysize(kServerSupportedSchemes) == kServerSupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  static const Scheme kProxySupportedSchemes[] = {
+    AUTH_SCHEME_BASIC,
+    AUTH_SCHEME_DIGEST,
+    AUTH_SCHEME_NTLM,
+    AUTH_SCHEME_NEGOTIATE,
+    AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kProxySupportedSchemeCount = 6;
+  COMPILE_ASSERT(arraysize(kProxySupportedSchemes) == kProxySupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  static const Scheme kAttestationSupportedSchemes[] = {
+    AUTH_SCHEME_ATTESTATION,
+    AUTH_SCHEME_MOCK,
+  };
+  static const int kAttestationSupportedSchemeCount = 2;
+  COMPILE_ASSERT(arraysize(kProxySupportedSchemes) == kProxySupportedSchemeCount,
+                 http_auth_supported_schemes_size_mismatch);
+
+  switch (target) {
+    case AUTH_PROXY:
+      return std::vector<Scheme>(kProxySupportedSchemes, kProxySupportedSchemes + kProxySupportedSchemeCount);
+    case AUTH_SERVER:
+      return std::vector<Scheme>(kServerSupportedSchemes, kServerSupportedSchemes + kServerSupportedSchemeCount);
+    case ATTESTATION:
+      return std::vector<Scheme>(kAttestationSupportedSchemes, kAttestationSupportedSchemes + kAttestationSupportedSchemeCount);
+    default:
+      NOTREACHED();
+      return std::vector<Scheme>();
+  }
+}
+
+// static
 const char* HttpAuth::SchemeToString(Scheme scheme) {
   static const char* const kSchemeNames[] = {
     "basic",
@@ -135,6 +188,7 @@ const char* HttpAuth::SchemeToString(Scheme scheme) {
     "ntlm",
     "negotiate",
     "spdyproxy",
+    "attestation",
     "mock",
   };
   COMPILE_ASSERT(arraysize(kSchemeNames) == AUTH_SCHEME_MAX,
diff --git a/net/http/http_auth.h b/net/http/http_auth.h
index 5a2c7ac..9b00a3c 100644
--- a/net/http/http_auth.h
+++ b/net/http/http_auth.h
@@ -33,7 +33,8 @@ class NET_EXPORT_PRIVATE HttpAuth {
     // in an array, so start from 0.
     AUTH_PROXY = 0,
     AUTH_SERVER = 1,
-    AUTH_NUM_TARGETS = 2,
+    ATTESTATION = 2,
+    AUTH_NUM_TARGETS = 3,
   };
 
   // What the HTTP WWW-Authenticate/Proxy-Authenticate headers indicate about
@@ -93,6 +94,7 @@ class NET_EXPORT_PRIVATE HttpAuth {
     AUTH_SCHEME_NTLM,
     AUTH_SCHEME_NEGOTIATE,
     AUTH_SCHEME_SPDYPROXY,
+    AUTH_SCHEME_ATTESTATION,
     AUTH_SCHEME_MOCK,
     AUTH_SCHEME_MAX,
   };
@@ -119,6 +121,9 @@ class NET_EXPORT_PRIVATE HttpAuth {
   // messages.
   static std::string GetAuthTargetString(Target target);
 
+  // Returns vector of supported Schemes for given target;
+  static std::vector<Scheme> GetSupportedSchemes(Target target);
+
   // Returns a string representation of an authentication Scheme.
   static const char* SchemeToString(Scheme scheme);
 
diff --git a/net/http/http_auth_controller.cc b/net/http/http_auth_controller.cc
index 9cc57de..193d820 100644
--- a/net/http/http_auth_controller.cc
+++ b/net/http/http_auth_controller.cc
@@ -41,6 +41,12 @@ std::string AuthChallengeLogMessage(HttpResponseHeaders* headers) {
     msg.append(header_val);
   }
 
+  iter = NULL;
+  while (headers->EnumerateHeader(&iter, "attestation-challenge", &header_val)) {
+    msg.append("\n  Has header Attestation-Challenge: ");
+    msg.append(header_val);
+  }
+
   // RFC 4559 requires that a proxy indicate its support of NTLM/Negotiate
   // authentication with a "Proxy-Support: Session-Based-Authentication"
   // response header.
@@ -64,6 +70,8 @@ enum AuthTarget {
   AUTH_TARGET_SECURE_PROXY,
   AUTH_TARGET_SERVER,
   AUTH_TARGET_SECURE_SERVER,
+  AUTH_TARGET_ATTESTATION,
+  AUTH_TARGET_SECURE_ATTESTATION,
   AUTH_TARGET_MAX,
 };
 
@@ -79,6 +87,11 @@ AuthTarget DetermineAuthTarget(const HttpAuthHandler* handler) {
         return AUTH_TARGET_SECURE_SERVER;
       else
         return AUTH_TARGET_SERVER;
+    case HttpAuth::ATTESTATION:
+      if (handler->origin().SchemeIsSecure())
+        return AUTH_TARGET_SECURE_ATTESTATION;
+      else
+        return AUTH_TARGET_ATTESTATION;
     default:
       NOTREACHED();
       return AUTH_TARGET_MAX;
@@ -112,6 +125,8 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   NTLM Reject: 5
   //   Negotiate Start: 6
   //   Negotiate Reject: 7
+  //   TODO(sobel): update this comment?
+  //         because out of date from attestation
   static const int kEventBucketsEnd =
       HttpAuth::AUTH_SCHEME_MAX * AUTH_EVENT_MAX;
   int event_bucket = auth_scheme * AUTH_EVENT_MAX + auth_event;
@@ -138,6 +153,8 @@ void HistogramAuthEvent(HttpAuthHandler* handler, AuthEvent auth_event) {
   //   Negotiate Secure Proxy: 13
   //   Negotiate Server: 14
   //   Negotiate Secure Server: 15
+  //   TODO(sobel): update this comment?
+  //         because out of date from attestation
   if (auth_event != AUTH_EVENT_START)
     return;
   static const int kTargetBucketsEnd =
@@ -512,6 +529,7 @@ void HttpAuthController::PopulateAuthChallenge() {
   auth_info_->challenger = HostPortPair::FromURL(auth_origin_);
   auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
   auth_info_->realm = handler_->realm();
+  auth_info_->is_attestation = handler_->IsAttestation();
 }
 
 bool HttpAuthController::DisableOnAuthHandlerResult(int result) {
diff --git a/net/http/http_auth_handler.cc b/net/http/http_auth_handler.cc
index 7369ea5..28f6d1d 100644
--- a/net/http/http_auth_handler.cc
+++ b/net/http/http_auth_handler.cc
@@ -52,6 +52,8 @@ NetLog::EventType EventTypeFromAuthTarget(HttpAuth::Target target) {
     case HttpAuth::AUTH_PROXY:
       return NetLog::TYPE_AUTH_PROXY;
     case HttpAuth::AUTH_SERVER:
+    case HttpAuth::ATTESTATION:
+      // TODO(sobel): should attestation have its own netlog?
       return NetLog::TYPE_AUTH_SERVER;
     default:
       NOTREACHED();
@@ -93,6 +95,10 @@ bool HttpAuthHandler::AllowsExplicitCredentials() {
   return true;
 }
 
+bool HttpAuthHandler::IsAttestation() {
+  return false;
+}
+
 void HttpAuthHandler::OnGenerateAuthTokenComplete(int rv) {
   CompletionCallback callback = callback_;
   FinishGenerateAuthToken();
diff --git a/net/http/http_auth_handler.h b/net/http/http_auth_handler.h
index dfb50d4..9f63775 100644
--- a/net/http/http_auth_handler.h
+++ b/net/http/http_auth_handler.h
@@ -140,6 +140,9 @@ class NET_EXPORT_PRIVATE HttpAuthHandler {
   // cannot be determined.
   virtual bool AllowsExplicitCredentials();
 
+  // Returns whether this "auth handler" is actually an attestation handler
+  virtual bool IsAttestation();
+
  protected:
   enum Property {
     ENCRYPTS_IDENTITY = 1 << 0,
diff --git a/net/http/http_auth_handler_factory.cc b/net/http/http_auth_handler_factory.cc
index 9867bb9..3b5d127 100644
--- a/net/http/http_auth_handler_factory.cc
+++ b/net/http/http_auth_handler_factory.cc
@@ -12,6 +12,7 @@
 #include "net/http/http_auth_handler_basic.h"
 #include "net/http/http_auth_handler_digest.h"
 #include "net/http/http_auth_handler_ntlm.h"
+#include "net/http/http_attestation_handler.h"
 
 #if defined(USE_KERBEROS)
 #include "net/http/http_auth_handler_negotiate.h"
@@ -52,6 +53,8 @@ HttpAuthHandlerRegistryFactory* HttpAuthHandlerFactory::CreateDefault(
       "basic", new HttpAuthHandlerBasic::Factory());
   registry_factory->RegisterSchemeFactory(
       "digest", new HttpAuthHandlerDigest::Factory());
+  registry_factory->RegisterSchemeFactory(
+      "attestation", new HttpAttestationHandler::Factory());
 
 #if defined(USE_KERBEROS)
   HttpAuthHandlerNegotiate::Factory* negotiate_factory =
@@ -83,6 +86,23 @@ bool IsSupportedScheme(const std::vector<std::string>& supported_schemes,
   return it != supported_schemes.end();
 }
 
+bool IsSupportedSchemeForTarget(const std::string& scheme,
+                                HttpAuth::Target target) {
+
+  std::vector<HttpAuth::Scheme> supported_schemes = HttpAuth::GetSupportedSchemes(target);
+  std::vector<HttpAuth::Scheme>::iterator it = supported_schemes.begin();
+  bool found = false;
+  for (; it != supported_schemes.end(); ++it) {
+    if (LowerCaseEqualsASCII(scheme, HttpAuth::SchemeToString(*it))) {
+      found = true;
+      break;
+    };
+  }
+  supported_schemes.erase(it);
+  supported_schemes.clear();
+  return found;
+}
+
 }  // namespace
 
 HttpAuthHandlerRegistryFactory::HttpAuthHandlerRegistryFactory() {
@@ -141,6 +161,9 @@ HttpAuthHandlerRegistryFactory* HttpAuthHandlerRegistryFactory::Create(
   if (IsSupportedScheme(supported_schemes, "digest"))
     registry_factory->RegisterSchemeFactory(
         "digest", new HttpAuthHandlerDigest::Factory());
+  if (IsSupportedScheme(supported_schemes, "attestation"))
+    registry_factory->RegisterSchemeFactory(
+        "attestation", new HttpAttestationHandler::Factory());
   if (IsSupportedScheme(supported_schemes, "ntlm")) {
     HttpAuthHandlerNTLM::Factory* ntlm_factory =
         new HttpAuthHandlerNTLM::Factory();
@@ -191,6 +214,10 @@ int HttpAuthHandlerRegistryFactory::CreateAuthHandler(
     handler->reset();
     return ERR_UNSUPPORTED_AUTH_SCHEME;
   }
+  if (!IsSupportedSchemeForTarget(lower_scheme, target)) {
+    handler->reset();
+    return ERR_UNSUPPORTED_AUTH_SCHEME;
+  }
   DCHECK(it->second);
   return it->second->CreateAuthHandler(challenge, target, origin, reason,
                                        digest_nonce_count, net_log, handler);
diff --git a/net/http/http_cache_transaction.cc b/net/http/http_cache_transaction.cc
index 6481990..5d7587a 100644
--- a/net/http/http_cache_transaction.cc
+++ b/net/http/http_cache_transaction.cc
@@ -958,7 +958,8 @@ int HttpCache::Transaction::DoSuccessfulSendRequest() {
   bool authentication_failure = false;
 
   if (new_response->headers->response_code() == 401 ||
-      new_response->headers->response_code() == 407) {
+      new_response->headers->response_code() == 407 ||
+      new_response->headers->response_code() == 421) {
     auth_response_ = *new_response;
     if (!reading_)
       return OK;
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index cf67b1d..147d4a5 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -252,7 +252,6 @@ int HttpNetworkTransaction::RestartWithAuth(
     return ERR_UNEXPECTED;
   }
   pending_auth_target_ = HttpAuth::AUTH_NONE;
-
   auth_controllers_[target]->ResetAuth(credentials);
 
   DCHECK(callback_.is_null());
@@ -415,6 +414,7 @@ LoadState HttpNetworkTransaction::GetLoadState() const {
       return stream_request_->GetLoadState();
     case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:
     case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:
+    case STATE_GENERATE_ATTESTATION_COMPLETE:
     case STATE_SEND_REQUEST_COMPLETE:
       return LOAD_STATE_SENDING_REQUEST;
     case STATE_READ_HEADERS_COMPLETE:
@@ -641,6 +641,12 @@ int HttpNetworkTransaction::DoLoop(int result) {
       case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:
         rv = DoGenerateServerAuthTokenComplete(rv);
         break;
+      case STATE_GENERATE_ATTESTATION:
+        rv = DoGenerateAttestation();
+        break;
+      case STATE_GENERATE_ATTESTATION_COMPLETE:
+        rv = DoGenerateAttestationComplete(rv);
+        break;
       case STATE_INIT_REQUEST_BODY:
         DCHECK_EQ(OK, rv);
         rv = DoInitRequestBody();
@@ -831,6 +837,31 @@ int HttpNetworkTransaction::DoGenerateServerAuthToken() {
 int HttpNetworkTransaction::DoGenerateServerAuthTokenComplete(int rv) {
   DCHECK_NE(ERR_IO_PENDING, rv);
   if (rv == OK)
+    next_state_ = STATE_GENERATE_ATTESTATION;
+  return rv;
+}
+
+int HttpNetworkTransaction::DoGenerateAttestation() {
+  next_state_ = STATE_GENERATE_ATTESTATION_COMPLETE;
+  HttpAuth::Target target = HttpAuth::ATTESTATION;
+  if (!auth_controllers_[target].get()) {
+    auth_controllers_[target] =
+        new HttpAuthController(target,
+                               AuthURL(target),
+                               session_->http_auth_cache(),
+                               session_->http_auth_handler_factory());
+    if (request_->load_flags & LOAD_DO_NOT_USE_EMBEDDED_IDENTITY)
+      auth_controllers_[target]->DisableEmbeddedIdentity();
+  }
+
+  return auth_controllers_[target]->MaybeGenerateAuthToken(request_,
+                                                           io_callback_,
+                                                           net_log_);
+}
+
+int HttpNetworkTransaction::DoGenerateAttestationComplete(int rv) {
+  DCHECK_NE(ERR_IO_PENDING, rv);
+  if (rv == OK)
     next_state_ = STATE_INIT_REQUEST_BODY;
   return rv;
 }
@@ -880,11 +911,15 @@ void HttpNetworkTransaction::BuildRequestHeaders(bool using_proxy) {
   if (ShouldApplyServerAuth() && HaveAuth(HttpAuth::AUTH_SERVER))
     auth_controllers_[HttpAuth::AUTH_SERVER]->AddAuthorizationHeader(
         &request_headers_);
+  if (HaveAuth(HttpAuth::ATTESTATION))
+    auth_controllers_[HttpAuth::ATTESTATION]->AddAuthorizationHeader(
+        &request_headers_);
 
   request_headers_.MergeFrom(request_->extra_headers);
   response_.did_use_http_auth =
       request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) ||
       request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization);
+      // TODO(sobel): do I need to add to this...?
 }
 
 int HttpNetworkTransaction::DoInitRequestBody() {
@@ -1527,11 +1562,17 @@ int HttpNetworkTransaction::HandleAuthChallenge() {
   DCHECK(headers.get());
 
   int status = headers->response_code();
-  if (status != HTTP_UNAUTHORIZED &&
-      status != HTTP_PROXY_AUTHENTICATION_REQUIRED)
+  HttpAuth::Target target;
+  if (status == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
+    target = HttpAuth::AUTH_PROXY;
+  } else if (status == HTTP_UNAUTHORIZED) {
+    target = HttpAuth::AUTH_SERVER;
+  } else if (status == HTTP_ATTESTATION_REQUIRED) {
+    target = HttpAuth::ATTESTATION;
+  } else {
     return OK;
-  HttpAuth::Target target = status == HTTP_PROXY_AUTHENTICATION_REQUIRED ?
-                            HttpAuth::AUTH_PROXY : HttpAuth::AUTH_SERVER;
+  }
+
   if (target == HttpAuth::AUTH_PROXY && proxy_info_.is_direct())
     return ERR_UNEXPECTED_PROXY_AUTH;
 
@@ -1572,6 +1613,7 @@ GURL HttpNetworkTransaction::AuthURL(HttpAuth::Target target) const {
                   proxy_info_.proxy_server().host_port_pair().ToString());
     }
     case HttpAuth::AUTH_SERVER:
+    case HttpAuth::ATTESTATION:
       return request_->url;
     default:
      return GURL();
diff --git a/net/http/http_network_transaction.h b/net/http/http_network_transaction.h
index 24ab95b..610ad84 100644
--- a/net/http/http_network_transaction.h
+++ b/net/http/http_network_transaction.h
@@ -130,6 +130,8 @@ class NET_EXPORT_PRIVATE HttpNetworkTransaction
     STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE,
     STATE_GENERATE_SERVER_AUTH_TOKEN,
     STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE,
+    STATE_GENERATE_ATTESTATION,
+    STATE_GENERATE_ATTESTATION_COMPLETE,
     STATE_INIT_REQUEST_BODY,
     STATE_INIT_REQUEST_BODY_COMPLETE,
     STATE_BUILD_REQUEST,
@@ -166,6 +168,8 @@ class NET_EXPORT_PRIVATE HttpNetworkTransaction
   int DoGenerateProxyAuthTokenComplete(int result);
   int DoGenerateServerAuthToken();
   int DoGenerateServerAuthTokenComplete(int result);
+  int DoGenerateAttestation();
+  int DoGenerateAttestationComplete(int result);
   int DoInitRequestBody();
   int DoInitRequestBodyComplete(int result);
   int DoBuildRequest();
diff --git a/net/http/http_request_headers.cc b/net/http/http_request_headers.cc
index 9348e3e..e0e0ec1 100644
--- a/net/http/http_request_headers.cc
+++ b/net/http/http_request_headers.cc
@@ -19,6 +19,7 @@ const char HttpRequestHeaders::kAcceptCharset[] = "Accept-Charset";
 const char HttpRequestHeaders::kAcceptEncoding[] = "Accept-Encoding";
 const char HttpRequestHeaders::kAcceptLanguage[] = "Accept-Language";
 const char HttpRequestHeaders::kAuthorization[] = "Authorization";
+const char HttpRequestHeaders::kAttestation[] = "Attestation";
 const char HttpRequestHeaders::kCacheControl[] = "Cache-Control";
 const char HttpRequestHeaders::kConnection[] = "Connection";
 const char HttpRequestHeaders::kContentLength[] = "Content-Length";
diff --git a/net/http/http_request_headers.h b/net/http/http_request_headers.h
index 6178117..e03ec11 100644
--- a/net/http/http_request_headers.h
+++ b/net/http/http_request_headers.h
@@ -61,6 +61,7 @@ class NET_EXPORT HttpRequestHeaders {
   static const char kAcceptEncoding[];
   static const char kAcceptLanguage[];
   static const char kAuthorization[];
+  static const char kAttestation[];
   static const char kCacheControl[];
   static const char kConnection[];
   static const char kContentType[];
diff --git a/net/http/http_status_code_list.h b/net/http/http_status_code_list.h
index 75c2304..d365364 100644
--- a/net/http/http_status_code_list.h
+++ b/net/http/http_status_code_list.h
@@ -57,6 +57,7 @@ HTTP_STATUS(UNSUPPORTED_MEDIA_TYPE, 415, "Unsupported Media Type")
 HTTP_STATUS(REQUESTED_RANGE_NOT_SATISFIABLE, 416,
             "Requested Range Not Satisfiable")
 HTTP_STATUS(EXPECTATION_FAILED, 417, "Expectation Failed")
+HTTP_STATUS(ATTESTATION_REQUIRED, 421, "Attestation Required")
 
 // Server error 5xx
 HTTP_STATUS(INTERNAL_SERVER_ERROR, 500, "Internal Server Error")
diff --git a/net/net.gypi b/net/net.gypi
index cfa668a..e795baa 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -559,6 +559,8 @@
       'http/failing_http_transaction_factory.cc',
       'http/failing_http_transaction_factory.h',
       'http/http_atom_list.h',
+      'http/http_attestation_handler.cc',
+      'http/http_attestation_handler.h',
       'http/http_auth.cc',
       'http/http_auth.h',
       'http/http_auth_cache.cc',
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index e3e84d3..95737d2 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -175,6 +175,7 @@ URLRequestHttpJob::URLRequestHttpJob(
       response_cookies_save_index_(0),
       proxy_auth_state_(AUTH_STATE_DONT_NEED_AUTH),
       server_auth_state_(AUTH_STATE_DONT_NEED_AUTH),
+      attestation_state_(AUTH_STATE_DONT_NEED_AUTH),
       start_callback_(base::Bind(&URLRequestHttpJob::OnStartCompleted,
                                  base::Unretained(this))),
       notify_before_headers_sent_callback_(
@@ -1079,6 +1080,11 @@ bool URLRequestHttpJob::NeedsAuth() {
         return false;
       server_auth_state_ = AUTH_STATE_NEED_AUTH;
       return true;
+    case 421:
+      if (attestation_state_ == AUTH_STATE_CANCELED)
+        return false;
+      attestation_state_ = AUTH_STATE_NEED_AUTH;
+      return true;
   }
   return false;
 }
@@ -1090,10 +1096,11 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 
   // sanity checks:
   DCHECK(proxy_auth_state_ == AUTH_STATE_NEED_AUTH ||
-         server_auth_state_ == AUTH_STATE_NEED_AUTH);
+         server_auth_state_ == AUTH_STATE_NEED_AUTH ||
+         attestation_state_ == AUTH_STATE_NEED_AUTH);
   DCHECK((GetResponseHeaders()->response_code() == HTTP_UNAUTHORIZED) ||
-         (GetResponseHeaders()->response_code() ==
-          HTTP_PROXY_AUTHENTICATION_REQUIRED));
+         (GetResponseHeaders()->response_code() == HTTP_PROXY_AUTHENTICATION_REQUIRED) ||
+         (GetResponseHeaders()->response_code() == HTTP_ATTESTATION_REQUIRED));
 
   *result = response_info_->auth_challenge;
 }
@@ -1101,12 +1108,14 @@ void URLRequestHttpJob::GetAuthChallengeInfo(
 void URLRequestHttpJob::SetAuth(const AuthCredentials& credentials) {
   DCHECK(transaction_.get());
 
-  // Proxy gets set first, then WWW.
+  // Proxy gets set first, then WWW, then attestation
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_HAVE_AUTH;
-  } else {
-    DCHECK_EQ(server_auth_state_, AUTH_STATE_NEED_AUTH);
+  } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
     server_auth_state_ = AUTH_STATE_HAVE_AUTH;
+  } else {
+    DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
+    attestation_state_ = AUTH_STATE_HAVE_AUTH;
   }
 
   RestartTransactionWithAuth(credentials);
@@ -1116,9 +1125,11 @@ void URLRequestHttpJob::CancelAuth() {
   // Proxy gets set first, then WWW.
   if (proxy_auth_state_ == AUTH_STATE_NEED_AUTH) {
     proxy_auth_state_ = AUTH_STATE_CANCELED;
-  } else {
-    DCHECK_EQ(server_auth_state_, AUTH_STATE_NEED_AUTH);
+  } else if (server_auth_state_ == AUTH_STATE_NEED_AUTH) {
     server_auth_state_ = AUTH_STATE_CANCELED;
+  } else {
+    DCHECK_EQ(attestation_state_, AUTH_STATE_NEED_AUTH);
+    attestation_state_ = AUTH_STATE_CANCELED;
   }
 
   // These will be reset in OnStartCompleted.
diff --git a/net/url_request/url_request_http_job.h b/net/url_request/url_request_http_job.h
index d5aa5ba..39c3071 100644
--- a/net/url_request/url_request_http_job.h
+++ b/net/url_request/url_request_http_job.h
@@ -180,9 +180,10 @@ class NET_EXPORT_PRIVATE URLRequestHttpJob : public URLRequestJob {
   size_t response_cookies_save_index_;
   base::Time response_date_;
 
-  // Auth states for proxy and origin server.
+  // Auth states for proxy and origin server and attestation.
   AuthState proxy_auth_state_;
   AuthState server_auth_state_;
+  AuthState attestation_state_;
   AuthCredentials auth_credentials_;
 
   CompletionCallback start_callback_;
-- 
1.7.10.2 (Apple Git-33)

